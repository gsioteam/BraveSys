//=============================================================================
// This RPG Maker Plugin is generated by rmmzp
//=============================================================================

/*:
 * @target MZ
 * @plugindesc (v1.0.0) 
 *
 * @param Actor Color
 * @desc The background color of actor in battle scene.
 * @default 0x3366ff
 * @type string
 *
 * @command addState
 * @text Add State
 * @desc Guard skill
 *
 * @arg stateId
 * @text State ID
 * @type number
 * @desc The state ID.
 * @default 1
 *
 * @arg stacks
 * @text Stacks
 * @type number
 * @desc Amount of stacks.
 * @default 1
 *
 * @command taunt
 * @text Taunt
 * @desc Make target attack the actor.
 *
 * @command interrupt
 * @text Interrupt
 * @desc Interrupt a action.
 *
 * @arg successRate
 * @type number
 * @default 0.5
 *
 * @arg successMsg
 * @text Success Message
 * @type string
 *
 * @arg failMsg
 * @text Fail Message
 * @type string
 */
(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){

const SceneManager = require('./src/scene_manager');
const BattleScene = require('./src/battle');
const { Scene_Battle } = require('rmmz');

SceneManager.replaceSceneClass(Scene_Battle, BattleScene);
},{"./src/battle":38,"./src/scene_manager":53,"rmmz":32}],2:[function(require,module,exports){
(function (process){(function (){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * The Ease class provides a collection of easing functions for use with tween.js.
 */
var Easing = {
    Linear: {
        None: function (amount) {
            return amount;
        },
    },
    Quadratic: {
        In: function (amount) {
            return amount * amount;
        },
        Out: function (amount) {
            return amount * (2 - amount);
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount;
            }
            return -0.5 * (--amount * (amount - 2) - 1);
        },
    },
    Cubic: {
        In: function (amount) {
            return amount * amount * amount;
        },
        Out: function (amount) {
            return --amount * amount * amount + 1;
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount * amount;
            }
            return 0.5 * ((amount -= 2) * amount * amount + 2);
        },
    },
    Quartic: {
        In: function (amount) {
            return amount * amount * amount * amount;
        },
        Out: function (amount) {
            return 1 - --amount * amount * amount * amount;
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount * amount * amount;
            }
            return -0.5 * ((amount -= 2) * amount * amount * amount - 2);
        },
    },
    Quintic: {
        In: function (amount) {
            return amount * amount * amount * amount * amount;
        },
        Out: function (amount) {
            return --amount * amount * amount * amount * amount + 1;
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return 0.5 * amount * amount * amount * amount * amount;
            }
            return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);
        },
    },
    Sinusoidal: {
        In: function (amount) {
            return 1 - Math.cos((amount * Math.PI) / 2);
        },
        Out: function (amount) {
            return Math.sin((amount * Math.PI) / 2);
        },
        InOut: function (amount) {
            return 0.5 * (1 - Math.cos(Math.PI * amount));
        },
    },
    Exponential: {
        In: function (amount) {
            return amount === 0 ? 0 : Math.pow(1024, amount - 1);
        },
        Out: function (amount) {
            return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);
        },
        InOut: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            if ((amount *= 2) < 1) {
                return 0.5 * Math.pow(1024, amount - 1);
            }
            return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);
        },
    },
    Circular: {
        In: function (amount) {
            return 1 - Math.sqrt(1 - amount * amount);
        },
        Out: function (amount) {
            return Math.sqrt(1 - --amount * amount);
        },
        InOut: function (amount) {
            if ((amount *= 2) < 1) {
                return -0.5 * (Math.sqrt(1 - amount * amount) - 1);
            }
            return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);
        },
    },
    Elastic: {
        In: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
        },
        Out: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;
        },
        InOut: function (amount) {
            if (amount === 0) {
                return 0;
            }
            if (amount === 1) {
                return 1;
            }
            amount *= 2;
            if (amount < 1) {
                return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
            }
            return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;
        },
    },
    Back: {
        In: function (amount) {
            var s = 1.70158;
            return amount * amount * ((s + 1) * amount - s);
        },
        Out: function (amount) {
            var s = 1.70158;
            return --amount * amount * ((s + 1) * amount + s) + 1;
        },
        InOut: function (amount) {
            var s = 1.70158 * 1.525;
            if ((amount *= 2) < 1) {
                return 0.5 * (amount * amount * ((s + 1) * amount - s));
            }
            return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);
        },
    },
    Bounce: {
        In: function (amount) {
            return 1 - Easing.Bounce.Out(1 - amount);
        },
        Out: function (amount) {
            if (amount < 1 / 2.75) {
                return 7.5625 * amount * amount;
            }
            else if (amount < 2 / 2.75) {
                return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;
            }
            else if (amount < 2.5 / 2.75) {
                return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;
            }
            else {
                return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;
            }
        },
        InOut: function (amount) {
            if (amount < 0.5) {
                return Easing.Bounce.In(amount * 2) * 0.5;
            }
            return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;
        },
    },
};

var now;
// Include a performance.now polyfill.
// In node.js, use process.hrtime.
// eslint-disable-next-line
// @ts-ignore
if (typeof self === 'undefined' && typeof process !== 'undefined' && process.hrtime) {
    now = function () {
        // eslint-disable-next-line
        // @ts-ignore
        var time = process.hrtime();
        // Convert [seconds, nanoseconds] to milliseconds.
        return time[0] * 1000 + time[1] / 1000000;
    };
}
// In a browser, use self.performance.now if it is available.
else if (typeof self !== 'undefined' && self.performance !== undefined && self.performance.now !== undefined) {
    // This must be bound, because directly assigning this function
    // leads to an invocation exception in Chrome.
    now = self.performance.now.bind(self.performance);
}
// Use Date.now if it is available.
else if (Date.now !== undefined) {
    now = Date.now;
}
// Otherwise, use 'new Date().getTime()'.
else {
    now = function () {
        return new Date().getTime();
    };
}
var now$1 = now;

/**
 * Controlling groups of tweens
 *
 * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
 * In these cases, you may want to create your own smaller groups of tween
 */
var Group = /** @class */ (function () {
    function Group() {
        this._tweens = {};
        this._tweensAddedDuringUpdate = {};
    }
    Group.prototype.getAll = function () {
        var _this = this;
        return Object.keys(this._tweens).map(function (tweenId) {
            return _this._tweens[tweenId];
        });
    };
    Group.prototype.removeAll = function () {
        this._tweens = {};
    };
    Group.prototype.add = function (tween) {
        this._tweens[tween.getId()] = tween;
        this._tweensAddedDuringUpdate[tween.getId()] = tween;
    };
    Group.prototype.remove = function (tween) {
        delete this._tweens[tween.getId()];
        delete this._tweensAddedDuringUpdate[tween.getId()];
    };
    Group.prototype.update = function (time, preserve) {
        if (time === void 0) { time = now$1(); }
        if (preserve === void 0) { preserve = false; }
        var tweenIds = Object.keys(this._tweens);
        if (tweenIds.length === 0) {
            return false;
        }
        // Tweens are updated in "batches". If you add a new tween during an
        // update, then the new tween will be updated in the next batch.
        // If you remove a tween during an update, it may or may not be updated.
        // However, if the removed tween was added during the current batch,
        // then it will not be updated.
        while (tweenIds.length > 0) {
            this._tweensAddedDuringUpdate = {};
            for (var i = 0; i < tweenIds.length; i++) {
                var tween = this._tweens[tweenIds[i]];
                var autoStart = !preserve;
                if (tween && tween.update(time, autoStart) === false && !preserve) {
                    delete this._tweens[tweenIds[i]];
                }
            }
            tweenIds = Object.keys(this._tweensAddedDuringUpdate);
        }
        return true;
    };
    return Group;
}());

/**
 *
 */
var Interpolation = {
    Linear: function (v, k) {
        var m = v.length - 1;
        var f = m * k;
        var i = Math.floor(f);
        var fn = Interpolation.Utils.Linear;
        if (k < 0) {
            return fn(v[0], v[1], f);
        }
        if (k > 1) {
            return fn(v[m], v[m - 1], m - f);
        }
        return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
    },
    Bezier: function (v, k) {
        var b = 0;
        var n = v.length - 1;
        var pw = Math.pow;
        var bn = Interpolation.Utils.Bernstein;
        for (var i = 0; i <= n; i++) {
            b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
        }
        return b;
    },
    CatmullRom: function (v, k) {
        var m = v.length - 1;
        var f = m * k;
        var i = Math.floor(f);
        var fn = Interpolation.Utils.CatmullRom;
        if (v[0] === v[m]) {
            if (k < 0) {
                i = Math.floor((f = m * (1 + k)));
            }
            return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
        }
        else {
            if (k < 0) {
                return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
            }
            if (k > 1) {
                return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
            }
            return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
        }
    },
    Utils: {
        Linear: function (p0, p1, t) {
            return (p1 - p0) * t + p0;
        },
        Bernstein: function (n, i) {
            var fc = Interpolation.Utils.Factorial;
            return fc(n) / fc(i) / fc(n - i);
        },
        Factorial: (function () {
            var a = [1];
            return function (n) {
                var s = 1;
                if (a[n]) {
                    return a[n];
                }
                for (var i = n; i > 1; i--) {
                    s *= i;
                }
                a[n] = s;
                return s;
            };
        })(),
        CatmullRom: function (p0, p1, p2, p3, t) {
            var v0 = (p2 - p0) * 0.5;
            var v1 = (p3 - p1) * 0.5;
            var t2 = t * t;
            var t3 = t * t2;
            return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
        },
    },
};

/**
 * Utils
 */
var Sequence = /** @class */ (function () {
    function Sequence() {
    }
    Sequence.nextId = function () {
        return Sequence._nextId++;
    };
    Sequence._nextId = 0;
    return Sequence;
}());

var mainGroup = new Group();

/**
 * Tween.js - Licensed under the MIT license
 * https://github.com/tweenjs/tween.js
 * ----------------------------------------------
 *
 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
 * Thank you all, you're awesome!
 */
var Tween = /** @class */ (function () {
    function Tween(_object, _group) {
        if (_group === void 0) { _group = mainGroup; }
        this._object = _object;
        this._group = _group;
        this._isPaused = false;
        this._pauseStart = 0;
        this._valuesStart = {};
        this._valuesEnd = {};
        this._valuesStartRepeat = {};
        this._duration = 1000;
        this._initialRepeat = 0;
        this._repeat = 0;
        this._yoyo = false;
        this._isPlaying = false;
        this._reversed = false;
        this._delayTime = 0;
        this._startTime = 0;
        this._easingFunction = Easing.Linear.None;
        this._interpolationFunction = Interpolation.Linear;
        this._chainedTweens = [];
        this._onStartCallbackFired = false;
        this._id = Sequence.nextId();
        this._isChainStopped = false;
        this._goToEnd = false;
    }
    Tween.prototype.getId = function () {
        return this._id;
    };
    Tween.prototype.isPlaying = function () {
        return this._isPlaying;
    };
    Tween.prototype.isPaused = function () {
        return this._isPaused;
    };
    Tween.prototype.to = function (properties, duration) {
        // TODO? restore this, then update the 07_dynamic_to example to set fox
        // tween's to on each update. That way the behavior is opt-in (there's
        // currently no opt-out).
        // for (const prop in properties) this._valuesEnd[prop] = properties[prop]
        this._valuesEnd = Object.create(properties);
        if (duration !== undefined) {
            this._duration = duration;
        }
        return this;
    };
    Tween.prototype.duration = function (d) {
        this._duration = d;
        return this;
    };
    Tween.prototype.start = function (time) {
        if (this._isPlaying) {
            return this;
        }
        // eslint-disable-next-line
        this._group && this._group.add(this);
        this._repeat = this._initialRepeat;
        if (this._reversed) {
            // If we were reversed (f.e. using the yoyo feature) then we need to
            // flip the tween direction back to forward.
            this._reversed = false;
            for (var property in this._valuesStartRepeat) {
                this._swapEndStartRepeatValues(property);
                this._valuesStart[property] = this._valuesStartRepeat[property];
            }
        }
        this._isPlaying = true;
        this._isPaused = false;
        this._onStartCallbackFired = false;
        this._isChainStopped = false;
        this._startTime = time !== undefined ? (typeof time === 'string' ? now$1() + parseFloat(time) : time) : now$1();
        this._startTime += this._delayTime;
        this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat);
        return this;
    };
    Tween.prototype._setupProperties = function (_object, _valuesStart, _valuesEnd, _valuesStartRepeat) {
        for (var property in _valuesEnd) {
            var startValue = _object[property];
            var startValueIsArray = Array.isArray(startValue);
            var propType = startValueIsArray ? 'array' : typeof startValue;
            var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);
            // If `to()` specifies a property that doesn't exist in the source object,
            // we should not set that property in the object
            if (propType === 'undefined' || propType === 'function') {
                continue;
            }
            // Check if an Array was provided as property value
            if (isInterpolationList) {
                var endValues = _valuesEnd[property];
                if (endValues.length === 0) {
                    continue;
                }
                // handle an array of relative values
                endValues = endValues.map(this._handleRelativeValue.bind(this, startValue));
                // Create a local copy of the Array with the start value at the front
                _valuesEnd[property] = [startValue].concat(endValues);
            }
            // handle the deepness of the values
            if ((propType === 'object' || startValueIsArray) && startValue && !isInterpolationList) {
                _valuesStart[property] = startValueIsArray ? [] : {};
                // eslint-disable-next-line
                for (var prop in startValue) {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _valuesStart[property][prop] = startValue[prop];
                }
                _valuesStartRepeat[property] = startValueIsArray ? [] : {}; // TODO? repeat nested values? And yoyo? And array values?
                // eslint-disable-next-line
                // @ts-ignore FIXME?
                this._setupProperties(startValue, _valuesStart[property], _valuesEnd[property], _valuesStartRepeat[property]);
            }
            else {
                // Save the starting value, but only once.
                if (typeof _valuesStart[property] === 'undefined') {
                    _valuesStart[property] = startValue;
                }
                if (!startValueIsArray) {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
                }
                if (isInterpolationList) {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();
                }
                else {
                    _valuesStartRepeat[property] = _valuesStart[property] || 0;
                }
            }
        }
    };
    Tween.prototype.stop = function () {
        if (!this._isChainStopped) {
            this._isChainStopped = true;
            this.stopChainedTweens();
        }
        if (!this._isPlaying) {
            return this;
        }
        // eslint-disable-next-line
        this._group && this._group.remove(this);
        this._isPlaying = false;
        this._isPaused = false;
        if (this._onStopCallback) {
            this._onStopCallback(this._object);
        }
        return this;
    };
    Tween.prototype.end = function () {
        this._goToEnd = true;
        this.update(Infinity);
        return this;
    };
    Tween.prototype.pause = function (time) {
        if (time === void 0) { time = now$1(); }
        if (this._isPaused || !this._isPlaying) {
            return this;
        }
        this._isPaused = true;
        this._pauseStart = time;
        // eslint-disable-next-line
        this._group && this._group.remove(this);
        return this;
    };
    Tween.prototype.resume = function (time) {
        if (time === void 0) { time = now$1(); }
        if (!this._isPaused || !this._isPlaying) {
            return this;
        }
        this._isPaused = false;
        this._startTime += time - this._pauseStart;
        this._pauseStart = 0;
        // eslint-disable-next-line
        this._group && this._group.add(this);
        return this;
    };
    Tween.prototype.stopChainedTweens = function () {
        for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
            this._chainedTweens[i].stop();
        }
        return this;
    };
    Tween.prototype.group = function (group) {
        this._group = group;
        return this;
    };
    Tween.prototype.delay = function (amount) {
        this._delayTime = amount;
        return this;
    };
    Tween.prototype.repeat = function (times) {
        this._initialRepeat = times;
        this._repeat = times;
        return this;
    };
    Tween.prototype.repeatDelay = function (amount) {
        this._repeatDelayTime = amount;
        return this;
    };
    Tween.prototype.yoyo = function (yoyo) {
        this._yoyo = yoyo;
        return this;
    };
    Tween.prototype.easing = function (easingFunction) {
        this._easingFunction = easingFunction;
        return this;
    };
    Tween.prototype.interpolation = function (interpolationFunction) {
        this._interpolationFunction = interpolationFunction;
        return this;
    };
    Tween.prototype.chain = function () {
        var tweens = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            tweens[_i] = arguments[_i];
        }
        this._chainedTweens = tweens;
        return this;
    };
    Tween.prototype.onStart = function (callback) {
        this._onStartCallback = callback;
        return this;
    };
    Tween.prototype.onUpdate = function (callback) {
        this._onUpdateCallback = callback;
        return this;
    };
    Tween.prototype.onRepeat = function (callback) {
        this._onRepeatCallback = callback;
        return this;
    };
    Tween.prototype.onComplete = function (callback) {
        this._onCompleteCallback = callback;
        return this;
    };
    Tween.prototype.onStop = function (callback) {
        this._onStopCallback = callback;
        return this;
    };
    /**
     * @returns true if the tween is still playing after the update, false
     * otherwise (calling update on a paused tween still returns true because
     * it is still playing, just paused).
     */
    Tween.prototype.update = function (time, autoStart) {
        if (time === void 0) { time = now$1(); }
        if (autoStart === void 0) { autoStart = true; }
        if (this._isPaused)
            return true;
        var property;
        var elapsed;
        var endTime = this._startTime + this._duration;
        if (!this._goToEnd && !this._isPlaying) {
            if (time > endTime)
                return false;
            if (autoStart)
                this.start(time);
        }
        this._goToEnd = false;
        if (time < this._startTime) {
            return true;
        }
        if (this._onStartCallbackFired === false) {
            if (this._onStartCallback) {
                this._onStartCallback(this._object);
            }
            this._onStartCallbackFired = true;
        }
        elapsed = (time - this._startTime) / this._duration;
        elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;
        var value = this._easingFunction(elapsed);
        // properties transformations
        this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);
        if (this._onUpdateCallback) {
            this._onUpdateCallback(this._object, elapsed);
        }
        if (elapsed === 1) {
            if (this._repeat > 0) {
                if (isFinite(this._repeat)) {
                    this._repeat--;
                }
                // Reassign starting values, restart by making startTime = now
                for (property in this._valuesStartRepeat) {
                    if (!this._yoyo && typeof this._valuesEnd[property] === 'string') {
                        this._valuesStartRepeat[property] =
                            // eslint-disable-next-line
                            // @ts-ignore FIXME?
                            this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
                    }
                    if (this._yoyo) {
                        this._swapEndStartRepeatValues(property);
                    }
                    this._valuesStart[property] = this._valuesStartRepeat[property];
                }
                if (this._yoyo) {
                    this._reversed = !this._reversed;
                }
                if (this._repeatDelayTime !== undefined) {
                    this._startTime = time + this._repeatDelayTime;
                }
                else {
                    this._startTime = time + this._delayTime;
                }
                if (this._onRepeatCallback) {
                    this._onRepeatCallback(this._object);
                }
                return true;
            }
            else {
                if (this._onCompleteCallback) {
                    this._onCompleteCallback(this._object);
                }
                for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
                    // Make the chained tweens start exactly at the time they should,
                    // even if the `update()` method was called way past the duration of the tween
                    this._chainedTweens[i].start(this._startTime + this._duration);
                }
                this._isPlaying = false;
                return false;
            }
        }
        return true;
    };
    Tween.prototype._updateProperties = function (_object, _valuesStart, _valuesEnd, value) {
        for (var property in _valuesEnd) {
            // Don't update properties that do not exist in the source object
            if (_valuesStart[property] === undefined) {
                continue;
            }
            var start = _valuesStart[property] || 0;
            var end = _valuesEnd[property];
            var startIsArray = Array.isArray(_object[property]);
            var endIsArray = Array.isArray(end);
            var isInterpolationList = !startIsArray && endIsArray;
            if (isInterpolationList) {
                _object[property] = this._interpolationFunction(end, value);
            }
            else if (typeof end === 'object' && end) {
                // eslint-disable-next-line
                // @ts-ignore FIXME?
                this._updateProperties(_object[property], start, end, value);
            }
            else {
                // Parses relative end values with start as base (e.g.: +10, -3)
                end = this._handleRelativeValue(start, end);
                // Protect against non numeric properties.
                if (typeof end === 'number') {
                    // eslint-disable-next-line
                    // @ts-ignore FIXME?
                    _object[property] = start + (end - start) * value;
                }
            }
        }
    };
    Tween.prototype._handleRelativeValue = function (start, end) {
        if (typeof end !== 'string') {
            return end;
        }
        if (end.charAt(0) === '+' || end.charAt(0) === '-') {
            return start + parseFloat(end);
        }
        else {
            return parseFloat(end);
        }
    };
    Tween.prototype._swapEndStartRepeatValues = function (property) {
        var tmp = this._valuesStartRepeat[property];
        var endValue = this._valuesEnd[property];
        if (typeof endValue === 'string') {
            this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);
        }
        else {
            this._valuesStartRepeat[property] = this._valuesEnd[property];
        }
        this._valuesEnd[property] = tmp;
    };
    return Tween;
}());

var VERSION = '18.6.4';

/**
 * Tween.js - Licensed under the MIT license
 * https://github.com/tweenjs/tween.js
 * ----------------------------------------------
 *
 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
 * Thank you all, you're awesome!
 */
var nextId = Sequence.nextId;
/**
 * Controlling groups of tweens
 *
 * Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
 * In these cases, you may want to create your own smaller groups of tweens.
 */
var TWEEN = mainGroup;
// This is the best way to export things in a way that's compatible with both ES
// Modules and CommonJS, without build hacks, and so as not to break the
// existing API.
// https://github.com/rollup/rollup/issues/1961#issuecomment-423037881
var getAll = TWEEN.getAll.bind(TWEEN);
var removeAll = TWEEN.removeAll.bind(TWEEN);
var add = TWEEN.add.bind(TWEEN);
var remove = TWEEN.remove.bind(TWEEN);
var update = TWEEN.update.bind(TWEEN);
var exports$1 = {
    Easing: Easing,
    Group: Group,
    Interpolation: Interpolation,
    now: now$1,
    Sequence: Sequence,
    nextId: nextId,
    Tween: Tween,
    VERSION: VERSION,
    getAll: getAll,
    removeAll: removeAll,
    add: add,
    remove: remove,
    update: update,
};

exports.Easing = Easing;
exports.Group = Group;
exports.Interpolation = Interpolation;
exports.Sequence = Sequence;
exports.Tween = Tween;
exports.VERSION = VERSION;
exports.add = add;
exports.default = exports$1;
exports.getAll = getAll;
exports.nextId = nextId;
exports.now = now$1;
exports.remove = remove;
exports.removeAll = removeAll;
exports.update = update;

}).call(this)}).call(this,require('_process'))
},{"_process":29}],3:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],4:[function(require,module,exports){
'use strict';


var loader = require('./lib/loader');
var dumper = require('./lib/dumper');


function renamed(from, to) {
  return function () {
    throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' +
      'Use yaml.' + to + ' instead, which is now safe by default.');
  };
}


module.exports.Type                = require('./lib/type');
module.exports.Schema              = require('./lib/schema');
module.exports.FAILSAFE_SCHEMA     = require('./lib/schema/failsafe');
module.exports.JSON_SCHEMA         = require('./lib/schema/json');
module.exports.CORE_SCHEMA         = require('./lib/schema/core');
module.exports.DEFAULT_SCHEMA      = require('./lib/schema/default');
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.dump                = dumper.dump;
module.exports.YAMLException       = require('./lib/exception');

// Re-export all types in case user wants to create custom schema
module.exports.types = {
  binary:    require('./lib/type/binary'),
  float:     require('./lib/type/float'),
  map:       require('./lib/type/map'),
  null:      require('./lib/type/null'),
  pairs:     require('./lib/type/pairs'),
  set:       require('./lib/type/set'),
  timestamp: require('./lib/type/timestamp'),
  bool:      require('./lib/type/bool'),
  int:       require('./lib/type/int'),
  merge:     require('./lib/type/merge'),
  omap:      require('./lib/type/omap'),
  seq:       require('./lib/type/seq'),
  str:       require('./lib/type/str')
};

// Removed functions from JS-YAML 3.0.x
module.exports.safeLoad            = renamed('safeLoad', 'load');
module.exports.safeLoadAll         = renamed('safeLoadAll', 'loadAll');
module.exports.safeDump            = renamed('safeDump', 'dump');

},{"./lib/dumper":6,"./lib/exception":7,"./lib/loader":8,"./lib/schema":9,"./lib/schema/core":10,"./lib/schema/default":11,"./lib/schema/failsafe":12,"./lib/schema/json":13,"./lib/type":15,"./lib/type/binary":16,"./lib/type/bool":17,"./lib/type/float":18,"./lib/type/int":19,"./lib/type/map":20,"./lib/type/merge":21,"./lib/type/null":22,"./lib/type/omap":23,"./lib/type/pairs":24,"./lib/type/seq":25,"./lib/type/set":26,"./lib/type/str":27,"./lib/type/timestamp":28}],5:[function(require,module,exports){
'use strict';


function isNothing(subject) {
  return (typeof subject === 'undefined') || (subject === null);
}


function isObject(subject) {
  return (typeof subject === 'object') && (subject !== null);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];

  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
}


module.exports.isNothing      = isNothing;
module.exports.isObject       = isObject;
module.exports.toArray        = toArray;
module.exports.repeat         = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend         = extend;

},{}],6:[function(require,module,exports){
'use strict';

/*eslint-disable no-use-before-define*/

var common              = require('./common');
var YAMLException       = require('./exception');
var DEFAULT_SCHEMA      = require('./schema/default');

var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_BOM                  = 0xFEFF;
var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_EQUALS               = 0x3D; /* = */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';

var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];

var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (map === null) return {};

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }
    type = schema.compiledTypeMap['fallback'][tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}


var QUOTING_TYPE_SINGLE = 1,
    QUOTING_TYPE_DOUBLE = 2;

function State(options) {
  this.schema        = options['schema'] || DEFAULT_SCHEMA;
  this.indent        = Math.max(1, (options['indent'] || 2));
  this.noArrayIndent = options['noArrayIndent'] || false;
  this.skipInvalid   = options['skipInvalid'] || false;
  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys      = options['sortKeys'] || false;
  this.lineWidth     = options['lineWidth'] || 80;
  this.noRefs        = options['noRefs'] || false;
  this.noCompatMode  = options['noCompatMode'] || false;
  this.condenseFlow  = options['condenseFlow'] || false;
  this.quotingType   = options['quotingType'] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes   = options['forceQuotes'] || false;
  this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length && line !== '\n') result += ind;

    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isnt mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
  return  (0x00020 <= c && c <= 0x00007E)
      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)
      ||  (0x10000 <= c && c <= 0x10FFFF);
}

// [34] ns-char ::= nb-char - s-white
// [27] nb-char ::= c-printable - b-char - c-byte-order-mark
// [26] b-char  ::= b-line-feed | b-carriage-return
// Including s-white (for some reason, examples doesn't match specs in this aspect)
// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark
function isNsCharOrWhitespace(c) {
  return isPrintable(c)
    && c !== CHAR_BOM
    // - b-char
    && c !== CHAR_CARRIAGE_RETURN
    && c !== CHAR_LINE_FEED;
}

// [127]  ns-plain-safe(c) ::= c = flow-out   ns-plain-safe-out
//                             c = flow-in    ns-plain-safe-in
//                             c = block-key  ns-plain-safe-out
//                             c = flow-key   ns-plain-safe-in
// [128] ns-plain-safe-out ::= ns-char
// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator
// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - : - # )
//                            | ( /* An ns-char preceding */ # )
//                            | ( : /* Followed by an ns-plain-safe(c) */ )
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    inblock ? // c = flow-in
      cIsNsCharOrWhitespace
      : cIsNsCharOrWhitespace
        // - c-flow-indicator
        && c !== CHAR_COMMA
        && c !== CHAR_LEFT_SQUARE_BRACKET
        && c !== CHAR_RIGHT_SQUARE_BRACKET
        && c !== CHAR_LEFT_CURLY_BRACKET
        && c !== CHAR_RIGHT_CURLY_BRACKET
  )
    // ns-plain-char
    && c !== CHAR_SHARP // false on '#'
    && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '
    || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'
    || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'
}

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  // No support of ( ( ? | : | - ) /* Followed by an ns-plain-safe(c)) */ ) part
  return isPrintable(c) && c !== CHAR_BOM
    && !isWhitespace(c) // - s-white
    // - (c-indicator ::=
    // - | ? | : | , | [ | ] | { | }
    && c !== CHAR_MINUS
    && c !== CHAR_QUESTION
    && c !== CHAR_COLON
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // | # | & | * | ! | | | = | > | ' | "
    && c !== CHAR_SHARP
    && c !== CHAR_AMPERSAND
    && c !== CHAR_ASTERISK
    && c !== CHAR_EXCLAMATION
    && c !== CHAR_VERTICAL_LINE
    && c !== CHAR_EQUALS
    && c !== CHAR_GREATER_THAN
    && c !== CHAR_SINGLE_QUOTE
    && c !== CHAR_DOUBLE_QUOTE
    // | % | @ | `)
    && c !== CHAR_PERCENT
    && c !== CHAR_COMMERCIAL_AT
    && c !== CHAR_GRAVE_ACCENT;
}

// Simplified test for values allowed as the last character in plain style.
function isPlainSafeLast(c) {
  // just not whitespace or colon, it will be checked to be plain character later
  return !isWhitespace(c) && c !== CHAR_COLON;
}

// Same as 'string'.codePointAt(pos), but works in older browsers.
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 0xDC00 && second <= 0xDFFF) {
      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
    }
  }
  return first;
}

// Determines whether block indentation indicator is required.
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}

var STYLE_PLAIN   = 1,
    STYLE_SINGLE  = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED  = 4,
    STYLE_DOUBLE  = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,
  testAmbiguousType, quotingType, forceQuotes, inblock) {

  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(codePointAt(string, 0))
          && isPlainSafeLast(codePointAt(string, string.length - 1));

  if (singleLineOnly || forceQuotes) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
            // Foldable line = too long, and not more-indented.
            (i - previousLineBreak - 1 > lineWidth &&
             string[previousLineBreak + 1] !== ' ');
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    // in case the end is missing a \n
    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
      (i - previousLineBreak - 1 > lineWidth &&
       string[previousLineBreak + 1] !== ' '));
  }
  // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak && !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  // Edge case: block indentation indicator can only have one digit.
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//     No ending newline => unaffected; already using strip "-" chomping.
//     Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = (function () {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? ('"' + string + '"') : ("'" + string + "'");
      }
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth  40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1
      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
      // No block styles in flow mode.
      || (state.flowLevel > -1 && level >= state.flowLevel);
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,
      testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {

      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string, lineWidth) + '"';
      default:
        throw new YAMLException('impossible error: invalid scalar style');
    }
  }());
}

// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

  // note the special case: the string '\n' counts as a "trailing" empty line.
  var clip =          string[string.length - 1] === '\n';
  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
  var chomp = keep ? '+' : (clip ? '' : '-');

  return indentIndicator + chomp + '\n';
}

// (See the note for writeScalar.)
function dropEndingNewline(string) {
  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
}

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlines
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g;

  // first line (possibly an empty line)
  var result = (function () {
    var nextLF = string.indexOf('\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }());
  // If we haven't reached the first content line yet, don't add an extra \n.
  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
  var moreIndented;

  // rest of the lines
  var match;
  while ((match = lineRe.exec(string))) {
    var prefix = match[1], line = match[2];
    moreIndented = (line[0] === ' ');
    result += prefix
      + (!prevMoreIndented && !moreIndented && line !== ''
        ? '\n' : '')
      + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line;

  // Since a more-indented line adds a \n, breaks can't be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0, end, curr = 0, next = 0;
  var result = '';

  // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.
  while ((match = breakRe.exec(line))) {
    next = match.index;
    // maintain invariant: curr - start <= width
    if (next - start > width) {
      end = (curr > start) ? curr : next; // derive end <= length-2
      result += '\n' + line.slice(start, end);
      // skip the space that was output as \n
      start = end + 1;                    // derive start <= length-1
    }
    curr = next;
  }

  // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += '\n';
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \n joiner
}

// Escapes a double-quoted string.
function escapeString(string) {
  var result = '';
  var char = 0;
  var escapeSeq;

  for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];

    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 0x10000) result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length,
      value;

  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];

    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }

    // Write only valid elements, put null instead of invalid elements.
    if (writeNode(state, level, value, false, false) ||
        (typeof value === 'undefined' &&
         writeNode(state, level, null, false, false))) {

      if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length,
      value;

  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];

    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }

    // Write only valid elements, put null instead of invalid elements.
    if (writeNode(state, level + 1, value, true, true, false, true) ||
        (typeof value === 'undefined' &&
         writeNode(state, level + 1, null, true, true, false, true))) {

      if (!compact || _result !== '') {
        _result += generateNextLine(state, level);
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {

    pairBuffer = '';
    if (_result !== '') pairBuffer += ', ';

    if (state.condenseFlow) pairBuffer += '"';

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';

    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new YAMLException('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || _result !== '') {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (state.tag !== null && state.tag !== '?') ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      if (explicit) {
        if (type.multi && type.representName) {
          state.tag = type.representName(object);
        } else {
          state.tag = type.tag;
        }
      } else {
        state.tag = '?';
      }

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);
  var inblock = block;
  var tagStr;

  if (block) {
    block = (state.flowLevel < 0 || state.flowLevel > level);
  }

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === '[object Object]') {
      if (block && (Object.keys(state.dump).length !== 0)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]') {
      if (block && (state.dump.length !== 0)) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type === '[object Undefined]') {
      return false;
    } else {
      if (state.skipInvalid) return false;
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (state.tag !== null && state.tag !== '?') {
      // Need to encode all characters except those allowed by the spec:
      //
      // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */
      // [36] ns-hex-digit    ::=  ns-dec-digit
      //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */
      // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */
      // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | -
      // [39] ns-uri-char     ::=  % ns-hex-digit ns-hex-digit | ns-word-char | #
      //                         | ; | / | ? | : | @ | & | = | + | $ | ,
      //                         | _ | . | ! | ~ | * | ' | ( | ) | [ | ]
      //
      // Also need to encode '!' because it has special meaning (end of tag prefix).
      //
      tagStr = encodeURI(
        state.tag[0] === '!' ? state.tag.slice(1) : state.tag
      ).replace(/!/g, '%21');

      if (state.tag[0] === '!') {
        tagStr = '!' + tagStr;
      } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {
        tagStr = '!!' + tagStr.slice(18);
      } else {
        tagStr = '!<' + tagStr + '>';
      }

      state.dump = tagStr + ' ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList,
      index,
      length;

  if (object !== null && typeof object === 'object') {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  var value = input;

  if (state.replacer) {
    value = state.replacer.call({ '': value }, '', value);
  }

  if (writeNode(state, 0, value, true, true)) return state.dump + '\n';

  return '';
}

module.exports.dump = dump;

},{"./common":5,"./exception":7,"./schema/default":11}],7:[function(require,module,exports){
// YAML error class. http://stackoverflow.com/questions/8458984
//
'use strict';


function formatError(exception, compact) {
  var where = '', message = exception.reason || '(unknown reason)';

  if (!exception.mark) return message;

  if (exception.mark.name) {
    where += 'in "' + exception.mark.name + '" ';
  }

  where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';

  if (!compact && exception.mark.snippet) {
    where += '\n\n' + exception.mark.snippet;
  }

  return message + ' ' + where;
}


function YAMLException(reason, mark) {
  // Super constructor
  Error.call(this);

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = (new Error()).stack || '';
  }
}


// Inherit from Error
YAMLException.prototype = Object.create(Error.prototype);
YAMLException.prototype.constructor = YAMLException;


YAMLException.prototype.toString = function toString(compact) {
  return this.name + ': ' + formatError(this, compact);
};


module.exports = YAMLException;

},{}],8:[function(require,module,exports){
'use strict';

/*eslint-disable max-len,no-use-before-define*/

var common              = require('./common');
var YAMLException       = require('./exception');
var makeSnippet         = require('./snippet');
var DEFAULT_SCHEMA      = require('./schema/default');


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function _class(obj) { return Object.prototype.toString.call(obj); }

function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C/* , */ ||
         c === 0x5B/* [ */ ||
         c === 0x5D/* ] */ ||
         c === 0x7B/* { */ ||
         c === 0x7D/* } */;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(
    ((c - 0x010000) >> 10) + 0xD800,
    ((c - 0x010000) & 0x03FF) + 0xDC00
  );
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  // (Hidden) Remove? makes the loader to expect YAML 1.1 documents
  // if such documents have no explicit %YAML directive
  this.legacy    = options['legacy']    || false;

  this.json      = options['json']      || false;
  this.listener  = options['listener']  || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  // position of first leading tab in the current line,
  // used to make sure there are no tabs in the indentation
  this.firstTabInLine = -1;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  var mark = {
    name:     state.filename,
    buffer:   state.input.slice(0, -1), // omit trailing \0
    position: state.position,
    line:     state.line,
    column:   state.position - state.lineStart
  };

  mark.snippet = makeSnippet(mark);

  return new YAMLException(message, mark);
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = (minor < 2);

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, 'tag prefix is malformed: ' + prefix);
    }

    state.tagMap[handle] = prefix;
  }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 ||
              (0x20 <= _character && _character <= 0x10FFFF))) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,
  startLine, startLineStart, startPos) {

  var index, quantity;

  // The output is a plain object here, so keys can only be strings.
  // We need to convert keyNode to a string, but doing so can hang the process
  // (deeply nested arrays that explode exponentially using aliases).
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);

    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, 'nested arrays are not supported inside keys');
      }

      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
        keyNode[index] = '[object Object]';
      }
    }
  }

  // Avoid code execution in load() via toString property
  // (still use its own toString for arrays, timestamps,
  // and whatever user schema extensions happen to have @@toStringTag)
  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
    keyNode = '[object Object]';
  }


  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json &&
        !_hasOwnProperty.call(overridableKeys, keyNode) &&
        _hasOwnProperty.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }

    // used for this specific key only because Object.defineProperty is slow
    if (keyNode === '__proto__') {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A/* LF */) {
    state.position++;
  } else if (ch === 0x0D/* CR */) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 0x09/* Tab */ && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23/* # */) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20/* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
      ch === state.input.charCodeAt(_position + 1) &&
      ch === state.input.charCodeAt(_position + 2)) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)      ||
      is_FLOW_INDICATOR(ch) ||
      ch === 0x23/* # */    ||
      ch === 0x26/* & */    ||
      ch === 0x2A/* * */    ||
      ch === 0x21/* ! */    ||
      ch === 0x7C/* | */    ||
      ch === 0x3E/* > */    ||
      ch === 0x27/* ' */    ||
      ch === 0x22/* " */    ||
      ch === 0x25/* % */    ||
      ch === 0x40/* @ */    ||
      ch === 0x60/* ` */) {
    return false;
  }

  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A/* : */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (ch === 0x23/* # */) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27/* ' */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27/* ' */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x27/* ' */) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22/* " */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22/* " */) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (ch === 0x5C/* \ */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _lineStart,
      _pos,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = Object.create(null),
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;/* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    } else if (ch === 0x2C/* , */) {
      // "flow collection entries can never be completely empty", as per YAML 1.2, section 7.4
      throwError(state, "expected the node content, but found ','");
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F/* ? */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line; // Save the current line.
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C/* , */) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (ch === 0x23/* # */) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (ch !== 0));
    }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (ch === 0x20/* Space */)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        // except for the first content line (cf. Example 8.1)
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else {
      // Keep all line breaks except the header line break.
      state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (ch !== 0)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  // there is a leading tab before this token, so it can't be a block sequence/mapping;
  // it can still be flow sequence/mapping or a scalar
  if (state.firstTabInLine !== -1) return false;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, 'tab characters must not be used in indentation');
    }

    if (ch !== 0x2D/* - */) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _keyLine,
      _keyLineStart,
      _keyPos,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      overridableKeys = Object.create(null),
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  // there is a leading tab before this token, so it can't be a block sequence/mapping;
  // it can still be flow sequence/mapping or a scalar
  if (state.firstTabInLine !== -1) return false;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, 'tab characters must not be used in indentation');
    }

    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

      if (ch === 0x3F/* ? */) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;

      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        // Neither implicit nor explicit notation.
        // Reading is done. Go to the epilogue.
        break;
      }

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A/* : */) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }

      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21/* ! */) return false;

  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C/* < */) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (ch === 0x21/* ! */) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (ch !== 0 && ch !== 0x3E/* > */);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

      if (ch === 0x21/* ! */) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, 'tag name is malformed: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;

  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26/* & */) return false;

  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A/* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!_hasOwnProperty.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      typeList,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }

  } else if (state.tag === '?') {
    // Implicit resolving is not allowed for non-scalar types, and '?'
    // non-specific tag is only automatically assigned to plain scalars.
    //
    // We only need to check kind conformity in case user explicitly assigns '?'
    // tag, for example like this: "!<?> [0]"
    //
    if (state.result !== null && state.kind !== 'scalar') {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }

    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type = state.implicitTypes[typeIndex];

      if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
        state.result = type.construct(state.result);
        state.tag = type.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== '!') {
    if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];
    } else {
      // looking for multi type
      type = null;
      typeList = state.typeMap.multi[state.kind || 'fallback'];

      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type = typeList[typeIndex];
          break;
        }
      }
    }

    if (!type) {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }

    if (state.result !== null && type.kind !== state.kind) {
      throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
    }

    if (!type.resolve(state.result, state.tag)) { // `state.result` updated in resolver if matched
      throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
    } else {
      state.result = type.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }
  return state.tag !== null ||  state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = Object.create(null);
  state.anchorMap = Object.create(null);

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25/* % */) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (ch !== 0 && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 &&
      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
      input += '\n';
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);

  var nullpos = input.indexOf('\0');

  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, 'null byte is not allowed in input');
  }

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
    options = iterator;
    iterator = null;
  }

  var documents = loadDocuments(input, options);

  if (typeof iterator !== 'function') {
    return documents;
  }

  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException('expected a single document in the stream, but found more');
}


module.exports.loadAll = loadAll;
module.exports.load    = load;

},{"./common":5,"./exception":7,"./schema/default":11,"./snippet":14}],9:[function(require,module,exports){
'use strict';

/*eslint-disable max-len*/

var YAMLException = require('./exception');
var Type          = require('./type');


function compileList(schema, name) {
  var result = [];

  schema[name].forEach(function (currentType) {
    var newIndex = result.length;

    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag &&
          previousType.kind === currentType.kind &&
          previousType.multi === currentType.multi) {

        newIndex = previousIndex;
      }
    });

    result[newIndex] = currentType;
  });

  return result;
}


function compileMap(/* lists... */) {
  var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {},
        multi: {
          scalar: [],
          sequence: [],
          mapping: [],
          fallback: []
        }
      }, index, length;

  function collectType(type) {
    if (type.multi) {
      result.multi[type.kind].push(type);
      result.multi['fallback'].push(type);
    } else {
      result[type.kind][type.tag] = result['fallback'][type.tag] = type;
    }
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}


function Schema(definition) {
  return this.extend(definition);
}


Schema.prototype.extend = function extend(definition) {
  var implicit = [];
  var explicit = [];

  if (definition instanceof Type) {
    // Schema.extend(type)
    explicit.push(definition);

  } else if (Array.isArray(definition)) {
    // Schema.extend([ type1, type2, ... ])
    explicit = explicit.concat(definition);

  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })
    if (definition.implicit) implicit = implicit.concat(definition.implicit);
    if (definition.explicit) explicit = explicit.concat(definition.explicit);

  } else {
    throw new YAMLException('Schema.extend argument should be a Type, [ Type ], ' +
      'or a schema definition ({ implicit: [...], explicit: [...] })');
  }

  implicit.forEach(function (type) {
    if (!(type instanceof Type)) {
      throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
    }

    if (type.loadKind && type.loadKind !== 'scalar') {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }

    if (type.multi) {
      throw new YAMLException('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');
    }
  });

  explicit.forEach(function (type) {
    if (!(type instanceof Type)) {
      throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
    }
  });

  var result = Object.create(Schema.prototype);

  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);

  result.compiledImplicit = compileList(result, 'implicit');
  result.compiledExplicit = compileList(result, 'explicit');
  result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);

  return result;
};


module.exports = Schema;

},{"./exception":7,"./type":15}],10:[function(require,module,exports){
// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.


'use strict';


module.exports = require('./json');

},{"./json":13}],11:[function(require,module,exports){
// JS-YAML's default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)


'use strict';


module.exports = require('./core').extend({
  implicit: [
    require('../type/timestamp'),
    require('../type/merge')
  ],
  explicit: [
    require('../type/binary'),
    require('../type/omap'),
    require('../type/pairs'),
    require('../type/set')
  ]
});

},{"../type/binary":16,"../type/merge":21,"../type/omap":23,"../type/pairs":24,"../type/set":26,"../type/timestamp":28,"./core":10}],12:[function(require,module,exports){
// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346


'use strict';


var Schema = require('../schema');


module.exports = new Schema({
  explicit: [
    require('../type/str'),
    require('../type/seq'),
    require('../type/map')
  ]
});

},{"../schema":9,"../type/map":20,"../type/seq":25,"../type/str":27}],13:[function(require,module,exports){
// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.


'use strict';


module.exports = require('./failsafe').extend({
  implicit: [
    require('../type/null'),
    require('../type/bool'),
    require('../type/int'),
    require('../type/float')
  ]
});

},{"../type/bool":17,"../type/float":18,"../type/int":19,"../type/null":22,"./failsafe":12}],14:[function(require,module,exports){
'use strict';


var common = require('./common');


// get snippet for a single line, respecting maxLength
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = '';
  var tail = '';
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;

  if (position - lineStart > maxHalfLength) {
    head = ' ... ';
    lineStart = position - maxHalfLength + head.length;
  }

  if (lineEnd - position > maxHalfLength) {
    tail = ' ...';
    lineEnd = position + maxHalfLength - tail.length;
  }

  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, '') + tail,
    pos: position - lineStart + head.length // relative position
  };
}


function padStart(string, max) {
  return common.repeat(' ', max - string.length) + string;
}


function makeSnippet(mark, options) {
  options = Object.create(options || null);

  if (!mark.buffer) return null;

  if (!options.maxLength) options.maxLength = 79;
  if (typeof options.indent      !== 'number') options.indent      = 1;
  if (typeof options.linesBefore !== 'number') options.linesBefore = 3;
  if (typeof options.linesAfter  !== 'number') options.linesAfter  = 2;

  var re = /\r?\n|\r|\0/g;
  var lineStarts = [ 0 ];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;

  while ((match = re.exec(mark.buffer))) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);

    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }

  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;

  var result = '', i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);

  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) +
      ' | ' + line.str + '\n' + result;
  }

  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) +
    ' | ' + line.str + '\n';
  result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\n';

  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) +
      ' | ' + line.str + '\n';
  }

  return result.replace(/\n$/, '');
}


module.exports = makeSnippet;

},{"./common":5}],15:[function(require,module,exports){
'use strict';

var YAMLException = require('./exception');

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'multi',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'representName',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.options       = options; // keep original options in case user wants to extend this type later
  this.tag           = tag;
  this.kind          = options['kind']          || null;
  this.resolve       = options['resolve']       || function () { return true; };
  this.construct     = options['construct']     || function (data) { return data; };
  this.instanceOf    = options['instanceOf']    || null;
  this.predicate     = options['predicate']     || null;
  this.represent     = options['represent']     || null;
  this.representName = options['representName'] || null;
  this.defaultStyle  = options['defaultStyle']  || null;
  this.multi         = options['multi']         || false;
  this.styleAliases  = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;

},{"./exception":7}],16:[function(require,module,exports){
'use strict';

/*eslint-disable no-bitwise*/


var Type = require('../type');


// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  if (data === null) return false;

  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  return new Uint8Array(result);
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(obj) {
  return Object.prototype.toString.call(obj) ===  '[object Uint8Array]';
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});

},{"../type":15}],17:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});

},{"../type":15}],18:[function(require,module,exports){
'use strict';

var common = require('../common');
var Type   = require('../type');

var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
  // .2e4, .2
  // special case, seems not from spec
  '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
  // .inf
  '|[-+]?\\.(?:inf|Inf|INF)' +
  // .nan
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
      // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = value[0] === '-' ? -1 : 1;

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if (value === '.nan') {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}


var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase': return '.nan';
      case 'uppercase': return '.NAN';
      case 'camelcase': return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '.inf';
      case 'uppercase': return '.INF';
      case 'camelcase': return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '-.inf';
      case 'uppercase': return '-.INF';
      case 'camelcase': return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return (Object.prototype.toString.call(object) === '[object Number]') &&
         (object % 1 !== 0 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});

},{"../common":5,"../type":15}],19:[function(require,module,exports){
'use strict';

var common = require('../common');
var Type   = require('../type');

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'o') {
      // base 8
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isOctCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }
  }

  // base 10 (except 0)

  // value should not start with `_`;
  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  // Should have digits and should not end with `_`
  if (!hasDigits || ch === '_') return false;

  return true;
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch;

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);
    if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);
  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return (Object.prototype.toString.call(object)) === '[object Number]' &&
         (object % 1 === 0 && !common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },
    octal:       function (obj) { return obj >= 0 ? '0o'  + obj.toString(8) : '-0o'  + obj.toString(8).slice(1); },
    decimal:     function (obj) { return obj.toString(10); },
    /* eslint-disable max-len */
    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});

},{"../common":5,"../type":15}],20:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return data !== null ? data : {}; }
});

},{"../type":15}],21:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});

},{"../type":15}],22:[function(require,module,exports){
'use strict';

var Type = require('../type');

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; },
    empty:     function () { return '';     }
  },
  defaultStyle: 'lowercase'
});

},{"../type":15}],23:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});

},{"../type":15}],24:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});

},{"../type":15}],25:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return data !== null ? data : []; }
});

},{"../type":15}],26:[function(require,module,exports){
'use strict';

var Type = require('../type');

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});

},{"../type":15}],27:[function(require,module,exports){
'use strict';

var Type = require('../type');

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return data !== null ? data : ''; }
});

},{"../type":15}],28:[function(require,module,exports){
'use strict';

var Type = require('../type');

var YAML_DATE_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9])'                    + // [2] month
  '-([0-9][0-9])$');                   // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:[Tt]|[ \\t]+)'                 + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});

},{"../type":15}],29:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],30:[function(require,module,exports){

module.exports = require('./src/richtext');
},{"./src/richtext":31}],31:[function(require,module,exports){

class LineState {
    constructor({ maxWidth }) {
        this.maxWidth = maxWidth;
        this.offset = {
            x: 0,
            y: 0,
        };
        this.lineHeight = 0;
        this.lineBlocks = [];
    }

    /**
     * 
     * @param {RichText} container 
     */
    newLine(container) {
        container._layoutLine(this.lineBlocks, this);
        this.lineBlocks = [];
        this.offset.x = 0;
        this.offset.y += this.lineHeight === 0 ? 12 : this.lineHeight;
        this.lineHeight = 0;
    }

    /**
     * 
     * @param {PIXI.DisplayObject} block 
     */
    addBlock(block) {
        block.x = this.offset.x;
        block.y = this.offset.y;
        this.offset.x += block.width;
        if (this.lineHeight < block.height) {
            this.lineHeight = block.height;
        }
        this.lineBlocks.push(block);
    }
}

class RichText extends PIXI.Container {
    
    /**
     * 
     * @param {String} text
     * @param {PIXI.TextStyle} textStyle
     * @param {Object} tagStyles
     */
    constructor(text, textStyle, tagStyles) {
        super();

        this._blocks = [];
        this._textStyle = textStyle;
        this.tagStyles = tagStyles;
        this.text = text;
    }

    get textStyle() {
        return this._textStyle;
    }

    set textStyle(style) {
        if (this._textStyle !== style) {
            this._textStyle = style;
            this.updateText();
        }
    }

    get text() {
        return this._text;
    }

    set text(text) {
        if (this._text !== text) {
            this._text = text;
            this.updateText();
        }
    }

    updateText() {
        for (let block of this._blocks) {
            block.destroy({
                children: true,
                texture: true,
                baseTexture: true,
            });
        }
        this._blocks = [];

        let width = this._textStyle.wordWrap ? this._textStyle.wordWrapWidth : null;
        let doc = this._parseHTML(this._text);
        
        let lineState = new LineState({
            maxWidth: width,
        });
        for (let node of doc.childNodes) {
            this._generateBlocks(node, this._textStyle, lineState);
        }
        lineState.newLine(this);
    }

    _parseHTML(html) {
        let div = document.createElement('div');
        div.innerHTML = html;
        return div;
    }

    /**
     * 
     * @param {HTMLElement} node 
     * @param {PIXI.TextStyle} textStyle 
     * @param {LineState} lineState 
     */
    _generateBlocks(node, textStyle, lineState) {
        if (node.nodeType == Node.TEXT_NODE) {
            let text = node.textContent;
            let restText;
            let offset = {
                x: lineState.offset.x,
                y: lineState.offset.y
            };
            let style = textStyle.clone();
            let newLine = false;
            let textMetrics;

            if (lineState.maxWidth) {
                style.wordWrap = true;
                style.wordWrapWidth = lineState.maxWidth - lineState.offset.x;
                textMetrics = PIXI.TextMetrics.measureText(text, style);
            } else {
                style.wordWrap = false;
                textMetrics = PIXI.TextMetrics.measureText(text, style);
            }
            if (lineState.offset.x > 0 && textMetrics.width > style.wordWrapWidth) {
                lineState.newLine(this);
                offset = {
                    x: lineState.offset.x,
                    y: lineState.offset.y,
                };
                if (lineState.maxWidth) {
                    style.wordWrapWidth = lineState.maxWidth - lineState.offset.x;
                }
                textMetrics = PIXI.TextMetrics.measureText(text, style);
            }
            if (textMetrics.lines.length > 1) {
                text = textMetrics.lines[0];
                restText = node.textContent.substring(text.length).trimStart();
                newLine = true;
            }

            let block = new PIXI.Text(text, style);
            block._linePadding = {
                top: block.height - textMetrics.fontProperties.ascent,
                bottom: textMetrics.fontProperties.descent,
            };
            lineState.addBlock(block);
            if (newLine) {
                lineState.newLine(this);
            }

            this._blocks.push(block);

            if (restText) {
                this._generateBlocks({
                    textContent: restText,
                    nodeType: Node.TEXT_NODE,
                }, textStyle, lineState);
            }
        } else if (node.nodeType == Node.ELEMENT_NODE) {
            let style = textStyle;
            let marginStyle = this.tagStyles[node.tagName.toLowerCase()];
            if (marginStyle) {
                style = textStyle.clone();
                for (let key in marginStyle) {
                    let value = marginStyle[key];
                    if (value) {
                        style[key] = value;
                    }
                }
            }
            for (let child of node.childNodes) {
                this._generateBlocks(child, style, lineState);
            }
        }
    }

    /**
     * 
     * @param {Array<PIXI.DisplayObject>} blocks 
     * @param {LineState} lineState 
     */
    _layoutLine(blocks, lineState) {
        let textBaseline = (this.textStyle.textBaseline || 'alphabetic').toLowerCase();
        for (let block of blocks) {
            switch (textBaseline) {
                case 'top': {
                    break;
                }
                case 'hanging': {
                    block.y = lineState.offset.y - block._linePadding.top;
                    break;
                }
                case 'middle': {
                    block.y = (lineState.lineHeight - block.height) / 2 + lineState.offset.y; 
                    break;
                }
                case 'alphabetic': {
                    block.y = (lineState.lineHeight - block.height) + lineState.offset.y + block._linePadding.bottom; 
                    break;
                }
                default: {
                    block.y = (lineState.lineHeight - block.height) + lineState.offset.y; 
                    break;
                }
            }
            this.addChild(block);
        }
    }
}

module.exports = RichText;
},{}],32:[function(require,module,exports){
module.exports = window
},{}],33:[function(require,module,exports){
// TinyColor v1.4.2
// https://github.com/bgrins/TinyColor
// Brian Grinstead, MIT License

(function(Math) {

var trimLeft = /^\s+/,
    trimRight = /\s+$/,
    tinyCounter = 0,
    mathRound = Math.round,
    mathMin = Math.min,
    mathMax = Math.max,
    mathRandom = Math.random;

function tinycolor (color, opts) {

    color = (color) ? color : '';
    opts = opts || { };

    // If input is already a tinycolor, return itself
    if (color instanceof tinycolor) {
       return color;
    }
    // If we are called as a function, call using new instead
    if (!(this instanceof tinycolor)) {
        return new tinycolor(color, opts);
    }

    var rgb = inputToRGB(color);
    this._originalInput = color,
    this._r = rgb.r,
    this._g = rgb.g,
    this._b = rgb.b,
    this._a = rgb.a,
    this._roundA = mathRound(100*this._a) / 100,
    this._format = opts.format || rgb.format;
    this._gradientType = opts.gradientType;

    // Don't let the range of [0,255] come back in [0,1].
    // Potentially lose a little bit of precision here, but will fix issues where
    // .5 gets interpreted as half of the total, instead of half of 1
    // If it was supposed to be 128, this was already taken care of by `inputToRgb`
    if (this._r < 1) { this._r = mathRound(this._r); }
    if (this._g < 1) { this._g = mathRound(this._g); }
    if (this._b < 1) { this._b = mathRound(this._b); }

    this._ok = rgb.ok;
    this._tc_id = tinyCounter++;
}

tinycolor.prototype = {
    isDark: function() {
        return this.getBrightness() < 128;
    },
    isLight: function() {
        return !this.isDark();
    },
    isValid: function() {
        return this._ok;
    },
    getOriginalInput: function() {
      return this._originalInput;
    },
    getFormat: function() {
        return this._format;
    },
    getAlpha: function() {
        return this._a;
    },
    getBrightness: function() {
        //http://www.w3.org/TR/AERT#color-contrast
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
    },
    getLuminance: function() {
        //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
        var rgb = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R, G, B;
        RsRGB = rgb.r/255;
        GsRGB = rgb.g/255;
        BsRGB = rgb.b/255;

        if (RsRGB <= 0.03928) {R = RsRGB / 12.92;} else {R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4);}
        if (GsRGB <= 0.03928) {G = GsRGB / 12.92;} else {G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4);}
        if (BsRGB <= 0.03928) {B = BsRGB / 12.92;} else {B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4);}
        return (0.2126 * R) + (0.7152 * G) + (0.0722 * B);
    },
    setAlpha: function(value) {
        this._a = boundAlpha(value);
        this._roundA = mathRound(100*this._a) / 100;
        return this;
    },
    toHsv: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
    },
    toHsvString: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
        return (this._a == 1) ?
          "hsv("  + h + ", " + s + "%, " + v + "%)" :
          "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
    },
    toHsl: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
    },
    toHslString: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
        return (this._a == 1) ?
          "hsl("  + h + ", " + s + "%, " + l + "%)" :
          "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
    },
    toHex: function(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
    },
    toHexString: function(allow3Char) {
        return '#' + this.toHex(allow3Char);
    },
    toHex8: function(allow4Char) {
        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
    },
    toHex8String: function(allow4Char) {
        return '#' + this.toHex8(allow4Char);
    },
    toRgb: function() {
        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
    },
    toRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
          "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
    },
    toPercentageRgb: function() {
        return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
    },
    toPercentageRgbString: function() {
        return (this._a == 1) ?
          "rgb("  + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
          "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
    },
    toName: function() {
        if (this._a === 0) {
            return "transparent";
        }

        if (this._a < 1) {
            return false;
        }

        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
    },
    toFilter: function(secondColor) {
        var hex8String = '#' + rgbaToArgbHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";

        if (secondColor) {
            var s = tinycolor(secondColor);
            secondHex8String = '#' + rgbaToArgbHex(s._r, s._g, s._b, s._a);
        }

        return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
    },
    toString: function(format) {
        var formatSet = !!format;
        format = format || this._format;

        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");

        if (needsAlphaFormat) {
            // Special case for "transparent", all other non-alpha formats
            // will return rgba when there is transparency.
            if (format === "name" && this._a === 0) {
                return this.toName();
            }
            return this.toRgbString();
        }
        if (format === "rgb") {
            formattedString = this.toRgbString();
        }
        if (format === "prgb") {
            formattedString = this.toPercentageRgbString();
        }
        if (format === "hex" || format === "hex6") {
            formattedString = this.toHexString();
        }
        if (format === "hex3") {
            formattedString = this.toHexString(true);
        }
        if (format === "hex4") {
            formattedString = this.toHex8String(true);
        }
        if (format === "hex8") {
            formattedString = this.toHex8String();
        }
        if (format === "name") {
            formattedString = this.toName();
        }
        if (format === "hsl") {
            formattedString = this.toHslString();
        }
        if (format === "hsv") {
            formattedString = this.toHsvString();
        }

        return formattedString || this.toHexString();
    },
    clone: function() {
        return tinycolor(this.toString());
    },

    _applyModification: function(fn, args) {
        var color = fn.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
    },
    lighten: function() {
        return this._applyModification(lighten, arguments);
    },
    brighten: function() {
        return this._applyModification(brighten, arguments);
    },
    darken: function() {
        return this._applyModification(darken, arguments);
    },
    desaturate: function() {
        return this._applyModification(desaturate, arguments);
    },
    saturate: function() {
        return this._applyModification(saturate, arguments);
    },
    greyscale: function() {
        return this._applyModification(greyscale, arguments);
    },
    spin: function() {
        return this._applyModification(spin, arguments);
    },

    _applyCombination: function(fn, args) {
        return fn.apply(null, [this].concat([].slice.call(args)));
    },
    analogous: function() {
        return this._applyCombination(analogous, arguments);
    },
    complement: function() {
        return this._applyCombination(complement, arguments);
    },
    monochromatic: function() {
        return this._applyCombination(monochromatic, arguments);
    },
    splitcomplement: function() {
        return this._applyCombination(splitcomplement, arguments);
    },
    triad: function() {
        return this._applyCombination(triad, arguments);
    },
    tetrad: function() {
        return this._applyCombination(tetrad, arguments);
    }
};

// If input is an object, force 1 into "1.0" to handle ratios properly
// String input requires "1.0" as input, so 1 will be treated as 1
tinycolor.fromRatio = function(color, opts) {
    if (typeof color == "object") {
        var newColor = {};
        for (var i in color) {
            if (color.hasOwnProperty(i)) {
                if (i === "a") {
                    newColor[i] = color[i];
                }
                else {
                    newColor[i] = convertToPercentage(color[i]);
                }
            }
        }
        color = newColor;
    }

    return tinycolor(color, opts);
};

// Given a string or object, convert that input to RGB
// Possible string inputs:
//
//     "red"
//     "#f00" or "f00"
//     "#ff0000" or "ff0000"
//     "#ff000000" or "ff000000"
//     "rgb 255 0 0" or "rgb (255, 0, 0)"
//     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
//     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
//     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
//     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
//     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
//     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
//
function inputToRGB(color) {

    var rgb = { r: 0, g: 0, b: 0 };
    var a = 1;
    var s = null;
    var v = null;
    var l = null;
    var ok = false;
    var format = false;

    if (typeof color == "string") {
        color = stringInputToObject(color);
    }

    if (typeof color == "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
            s = convertToPercentage(color.s);
            v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s, v);
            ok = true;
            format = "hsv";
        }
        else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
            s = convertToPercentage(color.s);
            l = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s, l);
            ok = true;
            format = "hsl";
        }

        if (color.hasOwnProperty("a")) {
            a = color.a;
        }
    }

    a = boundAlpha(a);

    return {
        ok: ok,
        format: color.format || format,
        r: mathMin(255, mathMax(rgb.r, 0)),
        g: mathMin(255, mathMax(rgb.g, 0)),
        b: mathMin(255, mathMax(rgb.b, 0)),
        a: a
    };
}


// Conversion Functions
// --------------------

// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

// `rgbToRgb`
// Handle bounds / percentage checking to conform to CSS color spec
// <http://www.w3.org/TR/css3-color/>
// *Assumes:* r, g, b in [0, 255] or [0, 1]
// *Returns:* { r, g, b } in [0, 255]
function rgbToRgb(r, g, b){
    return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255
    };
}

// `rgbToHsl`
// Converts an RGB color value to HSL.
// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
// *Returns:* { h, s, l } in [0,1]
function rgbToHsl(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max == min) {
        h = s = 0; // achromatic
    }
    else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }

        h /= 6;
    }

    return { h: h, s: s, l: l };
}

// `hslToRgb`
// Converts an HSL color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
function hslToRgb(h, s, l) {
    var r, g, b;

    h = bound01(h, 360);
    s = bound01(s, 100);
    l = bound01(l, 100);

    function hue2rgb(p, q, t) {
        if(t < 0) t += 1;
        if(t > 1) t -= 1;
        if(t < 1/6) return p + (q - p) * 6 * t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
    }

    if(s === 0) {
        r = g = b = l; // achromatic
    }
    else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHsv`
// Converts an RGB color value to HSV
// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
// *Returns:* { h, s, v } in [0,1]
function rgbToHsv(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, v = max;

    var d = max - min;
    s = max === 0 ? 0 : d / max;

    if(max == min) {
        h = 0; // achromatic
    }
    else {
        switch(max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h, s: s, v: v };
}

// `hsvToRgb`
// Converts an HSV color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
 function hsvToRgb(h, s, v) {

    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);

    var i = Math.floor(h),
        f = h - i,
        p = v * (1 - s),
        q = v * (1 - f * s),
        t = v * (1 - (1 - f) * s),
        mod = i % 6,
        r = [v, q, p, p, t, v][mod],
        g = [t, v, v, q, p, p][mod],
        b = [p, p, t, v, v, q][mod];

    return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHex`
// Converts an RGB color to hex
// Assumes r, g, and b are contained in the set [0, 255]
// Returns a 3 or 6 character hex
function rgbToHex(r, g, b, allow3Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    // Return a 3 character hex if possible
    if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }

    return hex.join("");
}

// `rgbaToHex`
// Converts an RGBA color plus alpha transparency to hex
// Assumes r, g, b are contained in the set [0, 255] and
// a in [0, 1]. Returns a 4 or 8 character rgba hex
function rgbaToHex(r, g, b, a, allow4Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16)),
        pad2(convertDecimalToHex(a))
    ];

    // Return a 4 character hex if possible
    if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
    }

    return hex.join("");
}

// `rgbaToArgbHex`
// Converts an RGBA color to an ARGB Hex8 string
// Rarely used, but required for "toFilter()"
function rgbaToArgbHex(r, g, b, a) {

    var hex = [
        pad2(convertDecimalToHex(a)),
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    return hex.join("");
}

// `equals`
// Can be called with any tinycolor input
tinycolor.equals = function (color1, color2) {
    if (!color1 || !color2) { return false; }
    return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};

tinycolor.random = function() {
    return tinycolor.fromRatio({
        r: mathRandom(),
        g: mathRandom(),
        b: mathRandom()
    });
};


// Modification Functions
// ----------------------
// Thanks to less.js for some of the basics here
// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

function desaturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function saturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function greyscale(color) {
    return tinycolor(color).desaturate(100);
}

function lighten (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

function brighten(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var rgb = tinycolor(color).toRgb();
    rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
    rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
    rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
    return tinycolor(rgb);
}

function darken (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
// Values outside of this range will be wrapped into this range.
function spin(color, amount) {
    var hsl = tinycolor(color).toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return tinycolor(hsl);
}

// Combination Functions
// ---------------------
// Thanks to jQuery xColor for some of the ideas behind these
// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

function complement(color) {
    var hsl = tinycolor(color).toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return tinycolor(hsl);
}

function triad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
    ];
}

function tetrad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
    ];
}

function splitcomplement(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
        tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
    ];
}

function analogous(color, results, slices) {
    results = results || 6;
    slices = slices || 30;

    var hsl = tinycolor(color).toHsl();
    var part = 360 / slices;
    var ret = [tinycolor(color)];

    for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor(hsl));
    }
    return ret;
}

function monochromatic(color, results) {
    results = results || 6;
    var hsv = tinycolor(color).toHsv();
    var h = hsv.h, s = hsv.s, v = hsv.v;
    var ret = [];
    var modification = 1 / results;

    while (results--) {
        ret.push(tinycolor({ h: h, s: s, v: v}));
        v = (v + modification) % 1;
    }

    return ret;
}

// Utility Functions
// ---------------------

tinycolor.mix = function(color1, color2, amount) {
    amount = (amount === 0) ? 0 : (amount || 50);

    var rgb1 = tinycolor(color1).toRgb();
    var rgb2 = tinycolor(color2).toRgb();

    var p = amount / 100;

    var rgba = {
        r: ((rgb2.r - rgb1.r) * p) + rgb1.r,
        g: ((rgb2.g - rgb1.g) * p) + rgb1.g,
        b: ((rgb2.b - rgb1.b) * p) + rgb1.b,
        a: ((rgb2.a - rgb1.a) * p) + rgb1.a
    };

    return tinycolor(rgba);
};


// Readability Functions
// ---------------------
// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

// `contrast`
// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
tinycolor.readability = function(color1, color2) {
    var c1 = tinycolor(color1);
    var c2 = tinycolor(color2);
    return (Math.max(c1.getLuminance(),c2.getLuminance())+0.05) / (Math.min(c1.getLuminance(),c2.getLuminance())+0.05);
};

// `isReadable`
// Ensure that foreground and background color combinations meet WCAG2 guidelines.
// The third argument is an optional Object.
//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
// If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

// *Example*
//    tinycolor.isReadable("#000", "#111") => false
//    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
tinycolor.isReadable = function(color1, color2, wcag2) {
    var readability = tinycolor.readability(color1, color2);
    var wcag2Parms, out;

    out = false;

    wcag2Parms = validateWCAG2Parms(wcag2);
    switch (wcag2Parms.level + wcag2Parms.size) {
        case "AAsmall":
        case "AAAlarge":
            out = readability >= 4.5;
            break;
        case "AAlarge":
            out = readability >= 3;
            break;
        case "AAAsmall":
            out = readability >= 7;
            break;
    }
    return out;

};

// `mostReadable`
// Given a base color and a list of possible foreground or background
// colors for that base, returns the most readable color.
// Optionally returns Black or White if the most readable color is unreadable.
// *Example*
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
tinycolor.mostReadable = function(baseColor, colorList, args) {
    var bestColor = null;
    var bestScore = 0;
    var readability;
    var includeFallbackColors, level, size ;
    args = args || {};
    includeFallbackColors = args.includeFallbackColors ;
    level = args.level;
    size = args.size;

    for (var i= 0; i < colorList.length ; i++) {
        readability = tinycolor.readability(baseColor, colorList[i]);
        if (readability > bestScore) {
            bestScore = readability;
            bestColor = tinycolor(colorList[i]);
        }
    }

    if (tinycolor.isReadable(baseColor, bestColor, {"level":level,"size":size}) || !includeFallbackColors) {
        return bestColor;
    }
    else {
        args.includeFallbackColors=false;
        return tinycolor.mostReadable(baseColor,["#fff", "#000"],args);
    }
};


// Big List of Colors
// ------------------
// <http://www.w3.org/TR/css3-color/#svg-color>
var names = tinycolor.names = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "0ff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000",
    blanchedalmond: "ffebcd",
    blue: "00f",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    burntsienna: "ea7e5d",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "0ff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkgrey: "a9a9a9",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkslategrey: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dimgrey: "696969",
    dodgerblue: "1e90ff",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "f0f",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    grey: "808080",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgray: "d3d3d3",
    lightgreen: "90ee90",
    lightgrey: "d3d3d3",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslategray: "789",
    lightslategrey: "789",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "0f0",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "f0f",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370db",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "db7093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "f00",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    slategrey: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    wheat: "f5deb3",
    white: "fff",
    whitesmoke: "f5f5f5",
    yellow: "ff0",
    yellowgreen: "9acd32"
};

// Make it easy to access colors via `hexNames[hex]`
var hexNames = tinycolor.hexNames = flip(names);


// Utilities
// ---------

// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
function flip(o) {
    var flipped = { };
    for (var i in o) {
        if (o.hasOwnProperty(i)) {
            flipped[o[i]] = i;
        }
    }
    return flipped;
}

// Return a valid alpha value [0,1] with all invalid values being set to 1
function boundAlpha(a) {
    a = parseFloat(a);

    if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
    }

    return a;
}

// Take input from [0, n] and return it as [0, 1]
function bound01(n, max) {
    if (isOnePointZero(n)) { n = "100%"; }

    var processPercent = isPercentage(n);
    n = mathMin(max, mathMax(0, parseFloat(n)));

    // Automatically convert percentage into number
    if (processPercent) {
        n = parseInt(n * max, 10) / 100;
    }

    // Handle floating point rounding errors
    if ((Math.abs(n - max) < 0.000001)) {
        return 1;
    }

    // Convert into [0, 1] range if it isn't already
    return (n % max) / parseFloat(max);
}

// Force a number between 0 and 1
function clamp01(val) {
    return mathMin(1, mathMax(0, val));
}

// Parse a base-16 hex value into a base-10 integer
function parseIntFromHex(val) {
    return parseInt(val, 16);
}

// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
function isOnePointZero(n) {
    return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
}

// Check to see if string passed in is a percentage
function isPercentage(n) {
    return typeof n === "string" && n.indexOf('%') != -1;
}

// Force a hex value to have 2 characters
function pad2(c) {
    return c.length == 1 ? '0' + c : '' + c;
}

// Replace a decimal with it's percentage value
function convertToPercentage(n) {
    if (n <= 1) {
        n = (n * 100) + "%";
    }

    return n;
}

// Converts a decimal to a hex value
function convertDecimalToHex(d) {
    return Math.round(parseFloat(d) * 255).toString(16);
}
// Converts a hex value to a decimal
function convertHexToDecimal(h) {
    return (parseIntFromHex(h) / 255);
}

var matchers = (function() {

    // <http://www.w3.org/TR/css3-values/#integers>
    var CSS_INTEGER = "[-\\+]?\\d+%?";

    // <http://www.w3.org/TR/css3-values/#number-value>
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

    // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
    var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

    // Actual matching.
    // Parentheses and commas are optional, but not required.
    // Whitespace can take the place of commas or opening paren
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

    return {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
})();

// `isValidCSSUnit`
// Take in a single string / number and check to see if it looks like a CSS unit
// (see `matchers` above for definition).
function isValidCSSUnit(color) {
    return !!matchers.CSS_UNIT.exec(color);
}

// `stringInputToObject`
// Permissive string parsing.  Take in a number of formats, and output an object
// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
function stringInputToObject(color) {

    color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
    var named = false;
    if (names[color]) {
        color = names[color];
        named = true;
    }
    else if (color == 'transparent') {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    }

    // Try to match string input using regular expressions.
    // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
    // Just return an object and let the conversion functions handle that.
    // This way the result will be the same whether the tinycolor is initialized with string or object.
    var match;
    if ((match = matchers.rgb.exec(color))) {
        return { r: match[1], g: match[2], b: match[3] };
    }
    if ((match = matchers.rgba.exec(color))) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
    }
    if ((match = matchers.hsl.exec(color))) {
        return { h: match[1], s: match[2], l: match[3] };
    }
    if ((match = matchers.hsla.exec(color))) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
    }
    if ((match = matchers.hsv.exec(color))) {
        return { h: match[1], s: match[2], v: match[3] };
    }
    if ((match = matchers.hsva.exec(color))) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
    }
    if ((match = matchers.hex8.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex6.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? "name" : "hex"
        };
    }
    if ((match = matchers.hex4.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            a: convertHexToDecimal(match[4] + '' + match[4]),
            format: named ? "name" : "hex8"
        };
    }
    if ((match = matchers.hex3.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            format: named ? "name" : "hex"
        };
    }

    return false;
}

function validateWCAG2Parms(parms) {
    // return valid WCAG2 parms for isReadable.
    // If input parms are invalid, return {"level":"AA", "size":"small"}
    var level, size;
    parms = parms || {"level":"AA", "size":"small"};
    level = (parms.level || "AA").toUpperCase();
    size = (parms.size || "small").toLowerCase();
    if (level !== "AA" && level !== "AAA") {
        level = "AA";
    }
    if (size !== "small" && size !== "large") {
        size = "small";
    }
    return {"level":level, "size":size};
}

// Node: Export function
if (typeof module !== "undefined" && module.exports) {
    module.exports = tinycolor;
}
// AMD/requirejs: Define the module
else if (typeof define === 'function' && define.amd) {
    define(function () {return tinycolor;});
}
// Browser: Expose to window
else {
    window.tinycolor = tinycolor;
}

})(Math);

},{}],34:[function(require,module,exports){
module.exports={
  "name": "g_battle",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "build": "rm -f ./g_battle.js\nrmpm .\nmv -f ./g_battle.js ../js/plugins/g_battle.js"
  },
  "author": "",
  "license": "MIT",
  "params": [
    {
      "name": "Actor Color",
      "description": "The background color of actor in battle scene.",
      "default": "0x3366ff",
      "type": "string"
    }
  ],
  "commands": [
    {
      "name": "addState",
      "text": "Add State",
      "description": "Guard skill",
      "args": [
        {
          "name": "stateId",
          "text": "State ID",
          "description": "The state ID.",
          "type": "number",
          "default": "1"
        },
        {
          "name": "stacks",
          "text": "Stacks",
          "description": "Amount of stacks.",
          "type": "number",
          "default": "1"
        }
      ]
    }, 
    {
      "name": "taunt",
      "text": "Taunt",
      "description": "Make target attack the actor."
    },
    {
      "name": "interrupt",
      "text": "Interrupt",
      "description": "Interrupt a action.",
      "args": [
        {
          "name": "successRate",
          "type": "number",
          "default": "0.5"
        },
        {
          "name": "successMsg",
          "text": "Success Message",
          "type": "string"
        },
        {
          "name": "failMsg",
          "text": "Fail Message",
          "type": "string"
        }
      ]
    }
  ],
  "dependencies": {
    "@tweenjs/tween.js": "^18.6.4",
    "events": "^3.3.0",
    "js-yaml": "^4.1.0",
    "rm-rich": "^1.0.6",
    "rmmz": "https://github.com/gsioteam/Rpg-Maker-MZ-Typescript.git#707d157be21565dd6e853755eae59ebe4aed5b02",
    "tinycolor2": "^1.4.2"
  },
  "devDependencies": {
    "rmpm": "^1.0.9"
  }
}

},{}],35:[function(require,module,exports){
const { Game_Actor, TextManager, Graphics, Game_Battler, RPG, Game_Action } = require("rmmz");
const Pager = require("./pager");
const List = require('./list');
const Button = require("./button");
const { Easing } = require("@tweenjs/tween.js");
const Input = require('./input');
const utils = require("./utils");
const Icon = require("./icon");

const _Size = {
    w: 120,
    h: 99
}

const CommandType = {
    Cancel: 0,
    Attack: 1,
    Guard: 2,
    Skip: 3,
    Skill: 4,
}

class Command {
    /**
     * 
     * @param {Object} options 
     * @param {number} options.type
     * @param {*} options.data
     */
    constructor({type, data}) {
        this.type = type;
        this.data = data;
    }
}

class SkillButton extends Button {

    /**
     * 
     * @param {Game_Action} action 
     */
    constructor(action) {
        let icon = new Icon(16, 16);
        let skill = action.item();
        icon.iconIndex = skill.iconIndex;
        super(80, 32, {
            text: skill.name,
            icon: icon,
            enable: action.subject().canUse(skill)
        });
    }
}

class ActionMenu extends Pager {
    /**
     * 
     * @param {Game_Actor} actor 
     * @param {Game_Battler} battler 
     */
    constructor(actor, battler) {
        let isDead = battler.isDead();
        let isEnemy = battler.isEnemy();
        let skills = actor.skills();
        let actions = skills.map((skill)=>{
            let action = new Game_Action(actor);
            action.setSkill(skill.id);
            return action;
        }).filter((action) => {
            if (isEnemy) {
                return action.isForOpponent();
            } else {
                if (isDead) {
                    return action.isForDeadFriend();
                }
                return action.isForFriend();
            }
        });
        let attackButton = new Button(80, 32, {
            text: TextManager.attack,
        });
        let skillButton = new Button(80, 32, {
            text: TextManager.skill,
        });
        let guardButton = new Button(80, 32, {
            text: TextManager.guard,
        });
        let skipButton = new Button(80, 32, {
            text: 'Skip',
        });

        let items = [
        ];
        if (isEnemy) {
            items.push(attackButton);
        } else {
            items.push(guardButton);
        }
        if (actions.length > 0) {
            items.push(skillButton);
        }
        items.push(skipButton);

        let list = new List({
            width: _Size.w,
            height: _Size.h,
            items: items
        });

        super(list);

        this._attackActions = actions;
        this._actor = actor;
        this._battler = battler;

        this.width = _Size.w;
        this.height = 0;

        attackButton.addListener('check', ()=>this._onAttack());
        skillButton.addListener('check', ()=>this._onSkill());
        guardButton.addListener('check', ()=>this._onGuard());
        skipButton.addListener('check', ()=>this._onSkip());
        
        this.active = false;

        Input.event('cancel').on('down', ()=>this._onCancel());
    }

    destroy(options) {
        this.emit('dismiss-details');
        super.destroy(options);
        Input.event('cancel').off('down', ()=>this._onCancel());
    }
    
    _onAttack() {
        this.emit('select', new Command({
            type: CommandType.Attack,
        }));
    }

    _onSkill() {
        let items = [];
        for (let action of this._attackActions) {
            let button = new SkillButton(action);
            button.on("check", () => {
                this.emit('select', new Command({
                    type: CommandType.Skill,
                    data: action.item(),
                }));
            });
            items.push(button);
        }
        let list = new List({
            width: _Size.w,
            height: _Size.h,
            items: items
        });
        let selectIndex = (idx) => {
            this.emit('details', this._attackActions[idx].item(), list.items[idx]);
        };
        list.on("highlight", selectIndex);
        this.push(list);
        selectIndex(0);
    }

    _onGuard() {
        this.emit('select', new Command({
            type: CommandType.Guard,
        }));
    }

    async _onCancel() {
        if (this.stack.length <= 1) {
            this.emit('select', new Command({
                type: CommandType.Cancel,
            }));
        } else {
            let child = await this.pop();
            child.destroy({
                children: true,
                texture: true,
                baseTexture: true,
            });
            this.emit('dismiss-details');
        }
    }

    _onSkip() {
        this.emit('select', new Command({
            type: CommandType.Skip,
        }));
    }

    /**
     * 
     * @param {number} x 
     * @param {number} y 
     * @returns {Promise<Command>}
     */
    async startSelection(x, y, details) {
        this.active = true;
        this.show(x, y);
        if (details) {
            details.x = this.x + this.width;
            details.y = this.y;
        }
        let command = await utils.until(this, 'select');
        await this.miss();
        return command;
    }
    
    async show(x, y) {
        this.x = x - this.width / 2;
        this.y = Math.min(y - 16, Graphics.height - _Size.h);
        await this.tweens.tween(this).to({
            height: _Size.h
        }, 300).easing(Easing.Cubic.Out).run();
    }

    async miss() {
        await this.tweens.tween(this).to({
            height: 0
        }, 300).easing(Easing.Cubic.Out).run();
        this.parent.removeChild(this);
    }
}

ActionMenu.Command = CommandType;

module.exports = ActionMenu;
},{"./button":41,"./icon":45,"./input":46,"./list":48,"./pager":50,"./utils":58,"@tweenjs/tween.js":2,"rmmz":32}],36:[function(require,module,exports){
const { Game_Actor, ImageManager, Bitmap, Graphics, Sprite } = require("rmmz");
const utils = require("./utils");
const tinycolor = require("tinycolor2");
const TweenManager = require("./tween_manager");
const { Easing } = require("@tweenjs/tween.js");
const StateIcon = require("./state_icon");
const Hint = require('./hint');

const _CircleSize = 80;
const _Padding = 2;
const _AvatarSize = _CircleSize - _Padding * 2;

const circleBitmap = new Bitmap(_CircleSize, _CircleSize);
circleBitmap.drawCircle(_CircleSize/2, _CircleSize/2, _CircleSize/2, '#ffffff');
const _circleTexture = new PIXI.Texture(circleBitmap.baseTexture);

/**
 * 
 * @param {HTMLCanvasElement} canvas 
 * @param {number} width 
 * @param {number} height 
 * @param {string} color 
 */
function drawRoundCanvas(canvas, width, height, color) {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = color;
    ctx.beginPath();
    if (width <= 0) {
    } else if (width > height) {
        ctx.moveTo(height/2, height);
        ctx.arc(height/2, height/2, height/2, Math.PI/2, -Math.PI/2);
        ctx.lineTo(width-height/2, 0);
        ctx.arc(width-height/2, height/2, height/2, -Math.PI/2, Math.PI/2);
        ctx.lineTo(height/2, height);
    } else {
        ctx.arc(width/2, height/2, width/2, 0, Math.PI*2);
    }
    ctx.closePath();
    ctx.fill();

}

function createRoundCanvas(width, height, color) {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;

    drawRoundCanvas(canvas, width, height, color);

    return canvas;
}

class RoundBar extends PIXI.Sprite {
    constructor(width, height, color) {
        let canvas = createRoundCanvas(width, height, color);
        super(PIXI.Texture.from(canvas));
        this._canvas = canvas;

        this._width = width;
        this._height = height;
        this._color = color;
    }

    get width() {
        return this._width;
    }

    set width(v) {
        if (this._width !== v) {
            this._width = v;

            drawRoundCanvas(this._canvas, this._width, this._height, this._color);
            this.texture.update();
        }
    }

    get height() {
        return this._height;
    }

    set height(v) {
        if (this._height !== v) {
            this._height = v;

            drawRoundCanvas(this._canvas, this._width, this._height, this._color);
            this.texture.update();
        }
    }

    set rate(v) {
        this.width = this._canvas.width * v;
    }
}

let textStyle = new PIXI.TextStyle({
    fontFamily: 'VL Gothic',
    fill: ['#ffffff'],
    stroke: '#004620',
    fontSize: 16,
    fontWeight: 'lighter',
    fontStyle: 'italic',
    lineJoin: 'round',
    strokeThickness: 4,
    stroke: '0x202040',
});

const _GaugeSize = {
    w: 180,
    h: 12,
};
class GaugeBar extends PIXI.Container {

    constructor({color, max, value}) {
        super();

        this.bitmap = new Bitmap(_GaugeSize.w, _GaugeSize.h);
        this.bitmap.drawCircle(_GaugeSize.h/2, _GaugeSize.h/2, _GaugeSize.h/2, '#000');
        this.bitmap.drawCircle(_GaugeSize.w - _GaugeSize.h/2, _GaugeSize.h/2, _GaugeSize.h/2, '#000');
        this.bitmap.fillRect(_GaugeSize.h/2, 0, _GaugeSize.w-_GaugeSize.h, _GaugeSize.h, '#000');
        let texture = new PIXI.Texture(this.bitmap.baseTexture);
        this._background = new PIXI.Sprite(texture);
        this._background.y = 10;
        this.addChild(this._background);
        
        function createGradTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 1;
            canvas.height = _GaugeSize.h;

            const ctx = canvas.getContext('2d');

            let tcolor = tinycolor(color);
            const grd = ctx.createLinearGradient(0, 0, 0, _GaugeSize.h);
            grd.addColorStop(0, tcolor.toRgbString());
            tcolor.darken(20);
            grd.addColorStop(1, tcolor.toRgbString());

            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, 1, _GaugeSize.h);

            return PIXI.Texture.from(canvas);
        }
        
        let barSize = {
            w: _GaugeSize.w - 4,
            h: _GaugeSize.h - 4
        };
        this._bar = new PIXI.Sprite(createGradTexture());
        this._bar.width = barSize.w;
        this._bar.height = barSize.h;
        this._bar.x = 2;
        this._bar.y = 12;
        this.addChild(this._bar);

        this._bar.mask = new RoundBar(barSize.w, barSize.h, '#ffffff');
        this._bar.mask.x = 2;
        this._bar.mask.y = 12;
        this.addChild(this._bar.mask);
        
        this._label = new PIXI.Text(`${value} / ${max}`, textStyle);
        this.addChild(this._label);

        this._max = max;
        this._value = value;

    }

    destroy(options) {
        super.destroy(options);
        this.bitmap.destroy();
    }

    set max(v) {
        v = Math.round(v);
        if (this._max !== v) {
            this._max = v;
            this._label.text = `${this._value} / ${this._max}`;
            this._bar.mask.rate = this._value / this._max;
        }
    }

    get max() {
        return this._max;
    }

    set value(v) {
        v = Math.round(v);
        if (this._value !== v) {
            this._value = v;
            this._label.text = `${this._value} / ${this._max}`;
            this._bar.mask.rate = this._value / this._max;
        }
    }

    get value() {
        return this._value;
    }
}

function createGlassBall(size) {
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    let ctx = canvas.getContext('2d');
    let grd = ctx.createRadialGradient(0, 0, size * 0.1, 0, 0, Math.sqrt(size * size + size * size));
    grd.addColorStop(0, '#99bfff');
    grd.addColorStop(0.5, '#00bfd9');
    grd.addColorStop(0.75, '#359');
    grd.addColorStop(0.84, '#99bfff');

    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(size/2, size/2, size/2, 0, Math.PI*2);
    ctx.closePath();
    ctx.fill();

    grd = ctx.createLinearGradient(0, 0, 0, size/2);
    grd.addColorStop(0, '#ffffff');
    grd.addColorStop(1, '#ffffff00');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.ellipse(size/2, size/4 + size*0.1, size/3, size/4, 0, 0, Math.PI * 2);
    ctx.fill();

    return PIXI.Texture.from(canvas);
}

let _glassBall = createGlassBall(28);

class EnergyGauge extends PIXI.Container {

    /**
     * 
     * @param {Game_Actor} actor 
     */
    constructor(actor) {
        super();
        this._actor = actor;
        
        let max = actor.maxTp() / 10;
        this._dots = [];
        for (let i = 0; i < max; ++i) {
            let bg = new PIXI.Sprite(_circleTexture);
            bg.width = 18;
            bg.height = 18;
            bg.x = i * 18;
            bg.tint = 0x000;
            this.addChild(bg);

            let dot = new PIXI.Sprite(_glassBall);
            dot.width = 14;
            dot.height = 14;
            dot.anchor.set(0.5);
            dot.y = 9;
            dot.x = 9 + 18 * i;
            this._dotScale = dot.scale.x;
            dot.scale.set(0);
            this.addChild(dot);
            this._dots.push(dot);
        }

        this.value = actor.tp;
    }

    get value() {
        return this._value;
    }

    set value(v) {
        if (this._value !== v) {
            this._value = v;
            let n = v / 10;
            for (let i = 0, t = this._dots.length; i < t; ++i) {
                let dot = this._dots[i];
                
                dot.scale.set(Math.min(1, Math.max(0, n - i)) * this._dotScale);
            }
        }
    }
}

class CircleAvatar extends PIXI.Container {

    /**
     * 
     * @param {Game_Actor} actor 
     */
    constructor(actor) {
        super();
        this._actor = actor;

        this._background = new PIXI.Sprite(_circleTexture);
        this._background.tint = 0x000;
        this.addChild(this._background);
        
        this._avatar = new PIXI.Sprite(PIXI.Texture.WHITE);
        this._avatar.width = _AvatarSize;
        this._avatar.height = _AvatarSize;
        this._avatar.tint = 0x666666;
        this._avatar.anchor.set(0.5);

        this._avatarContainer = new Sprite();
        this._avatarContainer.x = _Padding + _AvatarSize/2;
        this._avatarContainer.y = _Padding + _AvatarSize/2;
        this._avatarContainer.addChild(this._avatar);
        this.addChild(this._avatarContainer);

        this._avatarMask = new PIXI.Sprite(_circleTexture);
        this._avatarMask.x = _Padding;
        this._avatarMask.y = _Padding;
        this._avatarMask.width = _AvatarSize;
        this._avatarMask.height = _AvatarSize;
        this._avatar.mask = this._avatarMask;
        this.addChild(this._avatarMask);

        this._hpBar = new GaugeBar({
            color: '#ff0000',
            value: actor.hp,
            max: actor.mhp,
        });
        this._hpBar.x = _AvatarSize - 4;
        this._hpBar.y = 18;
        this.addChild(this._hpBar);

        this._mpBar = new GaugeBar({
            color: '#0000ff',
            value: actor.mp,
            max: actor.mmp,
        });
        this._mpBar.x = _AvatarSize - 4;
        this._mpBar.y = 34;
        this.addChild(this._mpBar);

        this._energyGauge = new EnergyGauge(actor);
        this._energyGauge.x = _AvatarSize - 4;
        this._energyGauge.y = 54;
        this.addChild(this._energyGauge);

        this._loadFace();

        this.tweens = new TweenManager();

        this._stateIcons = [];
        this._data = {};
        let _checkValue = (key) => {
            if (this._data[key] !== actor[key]) {
                this._data[key] = actor[key];
                return true;
            }
            return false;
        };
        this._onUpdate = ()=>{
            if (_checkValue('hp') || _checkValue('mhp')) {
                this.tweens.tween(this._hpBar).to({
                    value: actor.hp,
                    max: actor.mhp
                }, 300).easing(Easing.Cubic.Out).run();
            }

            if (_checkValue('mp') || _checkValue('mmp')) {
                this.tweens.tween(this._mpBar).to({
                    value: actor.mp,
                    max: actor.mmp
                }, 300).easing(Easing.Cubic.Out).run();
            }

            if (_checkValue('tp')) {
                this.tweens.tween(this._energyGauge).to({
                    value: actor.tp,
                }, 300).run();
            }
            this._updateStates();
        };
        this._onUpdate();
        Graphics.app.ticker.add(this._onUpdate);
    }

    destroy(options) {
        super.destroy(options);
        Graphics.app.ticker.remove(this._onUpdate);
        this.tweens.destroy();
    }

    async _loadFace() {
        let faceIndex = this._actor.faceIndex();
        const bitmap = ImageManager.loadFace(this._actor.faceName());
        await utils.bitmapReady(bitmap);

        const pw = ImageManager.faceWidth;
        const ph = ImageManager.faceHeight;
        const sw = pw;
        const sh = ph;
        const sx = Math.floor((faceIndex % 4) * pw + (pw - sw) / 2);
        const sy = Math.floor(Math.floor(faceIndex / 4) * ph + (ph - sh) / 2);
        this._avatar.texture = new PIXI.Texture(bitmap.baseTexture, new PIXI.Rectangle(sx, sy, sw, sh));
        this._avatar.tint = 0xffffff;
        this._avatar.width = _AvatarSize;
        this._avatar.height = _AvatarSize;
    }

    get statesData() {
        let buffs = this._actor.buffIcons().map((icon)=>{
            return {
                type: StateIcon.Type.Icon,
                iconIndex: icon,
                battler: this._actor,
            };
        });
        let states = this._actor.states().map((state) => {
            return {
                type: StateIcon.Type.State,
                state: state,
                battler: this._actor,
            };
        });
        return [...buffs, ...states];
    }

    _updateStates() {
        let states = this.statesData;
        if (this._stateIcons.length > states.length) {
            let icons = this._stateIcons.splice(states.length, this._stateIcons.length - states.length);
            for (let icon of icons) {
                icon.destroy({
                    children: true,
                    texture: true,
                    baseTexture: true,
                });
            }
        }

        for (let i = 0, t = states.length; i < t; ++i) {
            let state = states[i];
            if (i < this._stateIcons.length) {
                let icon = this._stateIcons[i];
                icon.setData(state);
            } else {
                let icon = new StateIcon();
                icon.setData(state);
                icon.x = _AvatarSize - 4 + i * (16 + 2);
                icon.y = -2;
                icon.interactive = true;
                this.addChild(icon);
                this._stateIcons.push(icon);
            }
        }
    }
}

class ActorState extends Sprite {

    /**
     * 
     * @param {Game_Actor} actor 
     */
    constructor(actor) {
        super();

        this._actor = actor;
        this._active = false;
        this._highlight = false;

        this._avatar = new CircleAvatar(actor);
        this.addChild(this._avatar);
    }

    get actor() {
        return this._actor;
    }

    get battler() {
        return this._actor;
    }

    get active() {
        return this._active;
    }

    set active(v) {
        if (this._active !== v) {
            this._active = v;
            this.interactive = v;

            this._updateSprite();
        }
    }

    get highlight() {
        return this._highlight;
    }

    set highlight(v) {
        if (this._highlight !== v) {
            this._highlight = v;
            this._updateSprite();
        }
    }

    get targetPosition() {
        let pos = this.getGlobalPosition();
        return {
            x: pos.x + _CircleSize/2,
            y: pos.y + 24,
        };
    }

    _updateSprite() {
        if (this.highlight && this.active) {
            this.setBlendColor([255, 255, 255, 64]);
        } else {
            this.setBlendColor([0, 0, 0, 0]);
        }
    }

    get avatar() {
        return this._avatar._avatarContainer;
    }
}

const _Size = {
    w: 280,
    h: 92
};

class ActorStateWindow extends PIXI.Container {

    constructor() {
        super();

        const {$gameParty} = require("rmmz");

        const MaxLineNum = 2;
        this._actors = [];
        let actors = $gameParty.members();
        for (let i = 0, t = actors.length; i < t; ++i) {
            let actor = actors[i];
            let state = new ActorState(actor);
            state.x = (i % MaxLineNum) * _Size.w;
            state.y = Math.floor(i / MaxLineNum) * _Size.h;
            this.addChild(state);
            this._actors.push(state);
        }
    }

    get actors() {
        return this._actors;
    }

    set active(v) {
        if (this._active !== v) {
            this._active = v;
            for (let state of this._states) {
                state.interactive = v;
            }
        }
    }

    get active() {
        return this._active;
    }

    findTargetSprite(target) {
        let avatar = this.actors.find((actor)=>actor._actor === target);
        if (avatar) {
            return avatar.avatar;
        }
    }
}

module.exports = ActorStateWindow;
},{"./hint":44,"./state_icon":56,"./tween_manager":57,"./utils":58,"@tweenjs/tween.js":2,"rmmz":32,"tinycolor2":33}],37:[function(require,module,exports){
const { Easing } = require("@tweenjs/tween.js");
const { PluginManager, Graphics, Game_Actor, ImageManager, Sprite } = require("rmmz");
const TweenManager = require("./tween_manager");

let params = PluginManager.parameters('g_battle');

const _Size = 420;
const _SpriteSize = 280;
class ActorStatus extends PIXI.Container {
    constructor() {
        super();

        let color = parseInt(params['Actor Color']);
        let r = (color >> 16) & 0xff;
        let g = (color >> 8) & 0xff;
        let b = color & 0xff;

        let rgb = (r, g, b) => ((r & 0xff) << 16) | ((g & 0xff) << 8) | (b & 0xff);

        this._bg0 = new PIXI.Sprite(PIXI.Texture.WHITE);
        this._bg0.tint = rgb(r + 0x33, g + 0x11, b);
        this._bg0.width = _Size * 1.2;
        this._bg0.height = _Size * 1.2;
        this._bg0.anchor.set(1, 0);
        this._bg0.position.set(_Size * 1.2 / 2, Graphics.height);
        // this._bg0.angle = 58;
        this._bg0.alpha = 0.9;
        this.addChild(this._bg0);

        this._bg1 = new PIXI.Sprite(PIXI.Texture.WHITE);
        this._bg1.tint = color;
        this._bg1.width = _Size;
        this._bg1.height = _Size;
        this._bg1.anchor.set(1, 0);
        this._bg1.position.set(_Size / 2, Graphics.height);
        // this._bg1.angle = 60;
        this.addChild(this._bg1);

        this._sprite = new Sprite();
        this._sprite.anchor.set(0, 1);
        this._sprite.position.set(0, Graphics.height);
        this.addChild(this._sprite);

        this.tweens = new TweenManager();
    }

    destroy(options) {
        super.destroy(options);
        this.tweens.destroy();
    }

    waitBitmap(bitmap) {
        return new Promise(function (resolve, reject) {
            bitmap.addLoadListener(resolve);
        });
    }

    /**
     * 
     * @param {Game_Actor} actor 
     */
    async show(actor) {
        let pictureName = `${actor.faceName()}_${actor.faceIndex() + 1}`;
        let bitmap = ImageManager.loadPicture(pictureName);
        if (!bitmap.isReady()) {
            await this.waitBitmap(bitmap);
        }
        let width = _SpriteSize;
        let height = _SpriteSize / bitmap.width * bitmap.height;
        let scale = _SpriteSize / bitmap.width;
        this._sprite.x = -width;
        this._sprite.bitmap = bitmap;
        this._sprite.scale.set(scale, scale);

        this.tweens.tween(this._bg0).to({
            angle: 58
        }, 300).easing(Easing.Cubic.Out).run();
        this.tweens.tween(this._bg1).to({
            angle: 60
        }, 300).delay(200).easing(Easing.Cubic.Out).run();
        await this.tweens.tween(this._sprite).to({
            x: -60
        }, 300).delay(300).easing(Easing.Cubic.Out).run();
    }

    async miss() {
        this.tweens.tween(this._sprite).to({
            x: -this._sprite.width
        }, 300).easing(Easing.Cubic.Out).run();
        this.tweens.tween(this._bg1).to({
            angle: 0
        }, 300).delay(200).easing(Easing.Cubic.Out).run();
        await this.tweens.tween(this._bg0).to({
            angle: 0
        }, 300).delay(300).easing(Easing.Cubic.Out).run();
    }
}

module.exports = ActorStatus;
},{"./tween_manager":57,"@tweenjs/tween.js":2,"rmmz":32}],38:[function(require,module,exports){
const { Game_Action, BattleManager, 
    Scene_Base, Rectangle, Graphics, 
    Window_BattleStatus, Game_Battler,
    Game_Actor, ImageManager, Window_BattleLog, 
    Sprite_AnimationMV, Sprite_Animation, Sprite,
    Game_Enemy, SceneManager, Scene_Gameover, PluginManager, 
    Scene_Map,
} = require("rmmz");
const utils = require('./utils');
const TweenManager = require('./tween_manager');
const { Easing } = require("@tweenjs/tween.js");
const Spriteset = require('./spriteset');
const List = require("./list");
const Button = require("./button");
const ActionMenu = require("./action_menu");
const ActorStatus = require("./actor_status");
const LogBox = require('./log_box');
const ActorStateWindow = require("./actor_state_window");
require('./pixi-mousewheel');
const createAnimation = require('./event_animation');
const BattleEvent = require("./battle_event");
const YAML = require('js-yaml');
const EventEmitter = require("events");
const package = require('../package.json');
const { BattlerController, EnemyController, PatternController } = require('./battler_controller');
const ItemDetails = require("./item_details");

/**
 * 
 * @param {Game_Action} action 
 */
Game_Battler.prototype.pushAction = function(action) {
    this._actions.push(action);
};

/**
 * 
 * @param {*} damage 
 * @param {Game_Battler} target 
 * @returns 
 */
Game_Action.prototype.applyGuard = function (damage, target) {
    let guardRate = target.states().reduce((value, current) => {
        const config = utils.noteData(current);
        if (config.dmgReduction) {
            value += target.stacks(current.id) * config.dmgReduction;
        }
        return value;
    }, 0);
    return damage * Math.max(0, (1 - (guardRate / 100)));
};

const _Random = 'random';
const _RandomPattern = [_Random];
const _battlerScripts = {};

class BattleScene extends Scene_Base {

    create() {
        super.create();
        this.tweens = new TweenManager();

        this._spriteset = new Spriteset();
        this.addChild(this._spriteset);
        
        this.createWindowLayer();

        this._logBox = new LogBox({
            width: Graphics.boxWidth,
            height: Scene_Base.prototype.calcWindowHeight(3, false)
        });
        this.addChild(this._logBox);

        this._actorStatus = new ActorStatus();
        this.addChild(this._actorStatus);

        this._observer = null;

        this._itemDetails = new ItemDetails();
        this._itemDetails.visible = false;
        this.addChild(this._itemDetails);
    }

    stop() {
        super.stop();
        this.tweens.destroy();
    }

    async start() {
        super.start();
        BattleManager.playBattleBgm();
        BattleManager.startBattle();

        await this.fadeIn(this.fadeSpeed(), false);

        const {$gameParty, $gameTroop} = require('rmmz');

        let enemies = $gameTroop.members();
        let members = $gameParty.members();

        for (let enemy of enemies) {
            let data = enemy.enemy();
            let config = utils.noteData(data);
            let Class = _battlerScripts[config.script];
            if (Class) {
                enemy._ai = new Class(enemy);
            } else {
                enemy._ai = new EnemyController(enemy);
            }
        }
        for (let actor of members) {
            let data = actor.actor();
            let config = utils.noteData(data);
            let Class = _battlerScripts[config.script];
            if (Class) {
                actor._ai = new Class(actor);
            } else {
                actor._ai = new BattlerController(actor);
            }
        }

        while (true) {

            $gameTroop.increaseTurn();
            for (let enemy of enemies) {
                if (enemy.isAlive()) {
                    enemy.gainTp(100);
                }
                enemy._ai.onTurnStart();
            }
            for (let actor of members) {
                if (actor.isAlive()) {
                    actor.gainTp(20);
                }
                actor._ai.onTurnStart();
            }

            for (let index = 0, t = members.length; index < t; ++index) {
                let actor = members[index];
                actor.clearActions();

                if (!actor.isAlive()) continue;
                await this._actorStatus.show(actor);

                if (actor.canMove()) {
                    while (true) {
                        let target = await this._spriteset.startTargetSelection();
                        let menu = new ActionMenu(actor, target);
                        menu.x = 60;
                        menu.y = 60;
                        let point = this._spriteset.point;
                        this.addChild(menu);
                        menu.on('details', (item, button) => {
                            this._itemDetails.visible = true;
                            this._itemDetails.setContent(item, actor);
                            let pos = button.getGlobalPosition();
                            if (menu.x > Graphics.width / 2) {
                                this._itemDetails.x = menu.x - this._itemDetails.width  - 2;
                            } else {
                                this._itemDetails.x = menu.x + menu.width + 2;
                            }
                            this._itemDetails.y = Math.min(pos.y, Graphics.height - button.height);
                        });
                        menu.on('dismiss-details', () => {
                            this._itemDetails.visible = false;
                        });
                        let command = await menu.startSelection(point.x, point.y, this._itemDetails);
                        menu.destroy();
                        let action;
                        let targets;
                        switch (command.type) {
                            case ActionMenu.Command.Cancel: {
                                break;
                            }
                            case ActionMenu.Command.Attack: {
                                action = new Game_Action(actor);
                                action.setAttack();
                                action.setTarget(target.index());
                                break;
                            }
                            case ActionMenu.Command.Guard: {
                                action = new Game_Action(actor);
                                action.setGuard();
                                break;
                            }
                            case ActionMenu.Command.Skill: {
                                action = new Game_Action(actor);
                                action.setSkill(command.data.id);
                                action.setTarget(target.index());
                                break;
                            }
                        }
    
                        if (action) {
                            let item = action.item();
                            if (actor.canUse(item)) {
                                actor.useItem(item);
                                targets = action.makeTargets();
                                actor._ai.onCast(action, targets);
                                this._spriteset.startActionAnimation(actor, targets, action);
                                this._logBox.displayAction(actor, action);
                                for (let target of targets) {
                                    action.apply(target);
                                    target._ai.onActed(action);
                                    this._logBox.displayResult(actor, target);
                                    this._logBox.displayBattlerStatus(target, false);
                                    this._spriteset.displayResultText(target);

                                    if (target.isDead()) {
                                        target._ai.onDead();
                                    }
                                }

                                $gameTroop.battleStatus = {
                                    targets,
                                    action,
                                    battleScene: this,
                                };
                                action.applyGlobal();
                                await this.waitForAction();
                                $gameTroop.battleStatus = null;
                            }

                            if ($gameTroop.isAllDead()) {
                                this._terminate();
                                BattleManager.processVictory();
                                await utils.wait(200);
                                BattleManager.updateBattleEnd();
                                return;
                            }
                        }
    
                        if (actor.tp < 10 || command.type === ActionMenu.Command.Skip) {
                            // Next
                            break;
                        }
                    }
                    actor.onAllActionsEnd();
                }

                await this._actorStatus.miss();

            }

            let aliveEnemies = $gameTroop.aliveMembers();
            for (let enemy of aliveEnemies) {
                let action;
                while ((action = enemy.currentAction()) != null) {
                    if (!action.isInterrupted()) {
                        let targets = action.makeTargets();
                        enemy._ai.onCast(action, targets);
                        let item = action.item();
                        if (enemy.canUse(item)) {
                            this._logBox.displayAction(enemy, action);
                            for (let target of targets) {
                                enemy.useItem(item);
                                action.apply(target);
                                target._ai.onActed(action);
                                utils.ee(action).emit('active');
                                SoundManager.playEnemyAttack();
                                this._logBox.displayResult(enemy, target);
                                this._logBox.displayBattlerStatus(target, false);
                                this.startEnemyAttackAnimation(target);

                                if (target.isDead()) {
                                    target._ai.onDead();
                                }
                                await utils.wait(200);
                            }
                            $gameTroop.battleStatus = {
                                targets,
                                action,
                                battleScene: this,
                            };
                            action.applyGlobal();
                            await this.waitForAction();
                            $gameTroop.battleStatus = null;
                        }
                    }
                    enemy.removeCurrentAction();
                }
                enemy.onAllActionsEnd();
                if ($gameParty.isAllDead()) {
                    this._terminate();
                    BattleManager.processDefeat();
                    await utils.wait(500);
                    BattleManager.updateBattleEnd();
                    return;
                }
                await utils.wait(200);
            }
            
            for (let enemy of enemies) {
                enemy.onTurnEnd();
                enemy._ai.onTurnEnd();
            }
            for (let actor of members) {
                actor.onTurnEnd();
                if (actor.isAlive()) {
                    this._logBox.displayBattlerStatus(actor, true);
                }
                actor._ai.onTurnEnd();
            }
            await utils.wait(500);

        }
    }

    _terminate() {
        $gameParty.onBattleEnd();
        $gameTroop.onBattleEnd();
        AudioManager.stopMe();
        if (this.shouldAutosave()) {
            this.requestAutosave();
        }
    }
    shouldAutosave() {
        return SceneManager.isNextScene(Scene_Map);
    };

    update() {
        $gameTroop.updateInterpreter();
        const active = this.isActive();
        $gameTimer.update(active);
        $gameScreen.update();
        super.update();
        if (this._currentCommand) {
            this._currentCommand.update();
        }

        if (this._observer !== null) {
            if (!$gameTroop.isEventRunning()) {
                this._observer.emit('finished');
            }
        }
    }

    fadeIn(duration, white) {
        super.startFadeIn(duration, white);
        return utils.wait(duration);
    }

    fadeOut(duration, white) {
        super.startFadeOut(duration, white);
        return utils.wait(duration);
    }

    async startEnemyAttackAnimation(target) {
        const {$gameParty, $dataAnimations} = require('rmmz');
        let sprite = this._spriteset.findTargetSprite(target);
        let animation = $dataAnimations[1];
        let animationSprite = createAnimation(animation, [sprite]);
        this.addChild(animationSprite);
        await utils.until(animationSprite, 'complete');
        animationSprite.destroy({
            children: true,
            texture: true,
            baseTexture: true,
        });
    }

    async waitForAction() {
        const {$gameTroop, $gameTemp} = require('rmmz');
        if ($gameTemp.isCommonEventReserved()) {
            $gameTroop.setupBattleEvent();
            this._observer = new EventEmitter();
            await utils.until(this._observer, 'finished');
            this._observer = null;
        }
    }

    static registerAIScript(name, Class) {
        _battlerScripts[name] = Class;
    }
}

Game_Battler.prototype.initTp = function() {
    this.setTp(0);
};

Game_Battler.prototype.chargeTpByDamage = function() {
};

const _Game_Battler_canUse = Game_Battler.prototype.canUse;
/**
 * 
 * @param {RPG.DataItemBase} data 
 * @param {Object|null} options
 * @param {Game_Action} options.action
 * @param {Game_Battler} options.target
 * @returns {boolean}
 */
Game_Battler.prototype.canUse = function (item, options) {
    const config = utils.noteData(item);
    let cooldown = this.getCooldownCount(item.id);
    if (cooldown > 0) {
        return false;
    }

    if (typeof config.canUse === 'string' && options !== null) {
        let formula = utils.formula(config.canUse, ['a', 'b', 'item', 'config']);
        let ret = formula({
            a: options.action.subject(),
            b: options.target,
            item: item,
            config: config,
        });
        if (!ret) return false;
    }
    return _Game_Battler_canUse.call(this, ...arguments);
};

const _Game_Battler_useItem = Game_Battler.prototype.useItem;
/**
 * 
 * @param {RPG.DataConsumable} item 
 */
Game_Battler.prototype.useItem = function (item) {
    const config = utils.noteData(item);
    if (typeof config.cooldown === 'number') {
        if (!this._cooldownMap) {
            this._cooldownMap = {};
        }
        this._cooldownMap[item.id] = config.cooldown;
    }
    _Game_Battler_useItem.call(this, ...arguments);
};

Game_Battler.prototype.getCooldownCount = function(itemId) {
    let cooldown = 0;
    if (this._cooldownMap) {
        cooldown = this._cooldownMap[itemId] || 0;
    }
    return cooldown;
}

const _Game_Battler_onTurnEnd = Game_Battler.prototype.onTurnEnd;
Game_Battler.prototype.onTurnEnd = function() {
    _Game_Battler_onTurnEnd.call(this);
    if (this._cooldownMap) {
        for (let id in this._cooldownMap) {
            let cooldown = this._cooldownMap[id];
            if (cooldown > 0) {
                this._cooldownMap[id] = cooldown - 1;
            }
        }
    }
};

let _Video_updateVisibility = Video._updateVisibility;
Video._updateVisibility = function (videoVisible) {
    _Video_updateVisibility.call(this, videoVisible);
    if (videoVisible) {
        this._element.style.removeProperty('pointerEvents');
    } else {
        this._element.style.pointerEvents = 'none';
    }
}

let _Video_createElement = Video._createElement;
Video._createElement = function () {
    _Video_createElement.call(this);
    this._element.style.pointerEvents = 'none';
};

let _Graphics_createErrorPrinter = Graphics._createErrorPrinter;
Graphics._createErrorPrinter = function () {
    _Graphics_createErrorPrinter.call(this);
    this._errorPrinter.style.pointerEvents = 'none';
};

const _Game_Battler_addState = Game_Battler.prototype.addState;
Game_Battler.prototype.addState = function (stateId, stacks, actor) {
    _Game_Battler_addState.call(this, stateId);
    stacks = stacks || 1;
    
    const { $dataStates } = require('rmmz');
    let state = $dataStates[stateId];
    if (!state) return;
    if (!state._config) {
        state._config = YAML.load(state.node);
        if (!state._config) state._config = {};
    }
    const config = utils.noteData(state);
    let maxstacks = config.maxstacks;
    if (!maxstacks) maxstacks = 1;
    let formula;
    if (typeof config.stacks === 'string') {
        formula = utils.formula(config.stacks, ['a', 'b', 'stacks', 'state', 'stateId', 'config']);
    }
    let params = {
        stacks,
        stateId,
        state,
        config
    };
    let stacksNum = stacks;
    if (formula) {
        params.a = actor;
        params.b = this;
        try {
            stacksNum = formula(params);
        } catch (e) {
            console.error(e);
        }
    }

    if (!this._stateStacks) {
        this._stateStacks = {};
    }

    let num = this._stateStacks[stateId];
    if (typeof num !== 'number') {
        num = 0;
    }
    this._stateStacks[stateId] = Math.min(num + stacksNum, maxstacks);
};

const _Game_Battler_removeState = Game_Battler.prototype.removeState;
Game_Battler.prototype.removeState = function(stateId) {
    _Game_Battler_removeState.call(this, stateId);
    if (this._stateStacks) {
        delete this._stateStacks[stateId];
    }
};

Game_Battler.prototype.stacks = function(stateId) {
    if (this._stateStacks) {
        let num = this._stateStacks[stateId];
        if (typeof num === 'number') {
            return num;
        }
    }
    return this.isStateAffected(stateId) ? 1 : 0;
};
Game_Action.prototype.isInterrupted = function () {
    return !!this._interrupted;
};

// Commands
PluginManager.registerCommand(package.name, "addState", ({stacks, stateId})=>{
    if ( $gameTroop.battleStatus ) {
        const { $dataStates } = require('rmmz');
        const { targets, action } = $gameTroop.battleStatus;
        const actor = action.subject();
        const state = $dataStates[stateId];
        if (!state) return;
        if (typeof stacks === 'string') {
            stacks = parseInt(stacks);
        }
        if (typeof stateId === 'string') {
            stateId = parseInt(stateId);
        }

        const config = utils.noteData(state);
        for (let target of targets) {
            target.addState(stateId, stacks, actor);
        }
    }
});
PluginManager.registerCommand(package.name, 'taunt', () => {
    if ( $gameTroop.battleStatus ) {
        const { targets, action } = $gameTroop.battleStatus;
        const actor = action.subject();
        for (const target of targets) {
            for (let i = 0, t = target.numActions(); i < t; ++i) {
                const enemyAction = target.action(i);
                enemyAction.setTarget(actor.index());
            }
        }
    }
});
PluginManager.registerCommand(package.name, 'interrupt', ({ successRate, successMsg, failMsg }) => {
    if ( $gameTroop.battleStatus ) {
        const { targets, action, battleScene } = $gameTroop.battleStatus;
        if (typeof successRate === 'string') successRate = parseFloat(successRate);

        for (const target of targets) {
            let activeActions = [];
            for (let i = 0, t = target.numActions(); i < t; ++i) {
                const enemyAction = target.action(i);
                if (!enemyAction._interrupted) {
                    activeActions.push(enemyAction);
                }
            }
            if (Math.random() < successRate) {
                if (activeActions.length > 0) {
                    let enemyAction = activeActions[Math.floor(Math.random() * activeActions.length)];
                    enemyAction._interrupted = true;
                }
                battleScene._logBox.add('<heal>Success!</heal>');
            } else {
                battleScene._logBox.add('<dmg>Failed!</dmg>');
            }
        }
    }
});

module.exports = BattleScene;


BattleScene.registerAIScript('pattern', PatternController);
},{"../package.json":34,"./action_menu":35,"./actor_state_window":36,"./actor_status":37,"./battle_event":39,"./battler_controller":40,"./button":41,"./event_animation":43,"./item_details":47,"./list":48,"./log_box":49,"./pixi-mousewheel":51,"./spriteset":55,"./tween_manager":57,"./utils":58,"@tweenjs/tween.js":2,"events":3,"js-yaml":4,"rmmz":32}],39:[function(require,module,exports){

const EventEmitter = require('events');
const { RPG, Game_Action, Game_Battler } = require('rmmz');

class BattleEvent extends EventEmitter {
    
    /**
     * 
     * @param {Object} options
     * @param {number} options.commonEventId 
     * @param {Game_Battler} options.target
     * @param {Game_Action} options.action
     */
    constructor(options) {
        super();
        const commonEventId = options.commonEventId;
        this.target = options.target;
        this.action = options.action;
        const { $dataCommonEvents } = require('rmmz');

        let commandEvent = $dataCommonEvents[commonEventId];

        this._interpreter = new Game_Interpreter();
        this._interpreter.setup(commandEvent.list);
    }

    update() {
        this._interpreter.update();
        if (!this.isActive()) {
            this.emit('finished');
        }
    }

    isActive() {
        return this._interpreter.isRunning();
    }

    get stateData() {
        return {
            target: this.target,
            action: this.action,
        };
    }
}

module.exports = BattleEvent;
},{"events":3,"rmmz":32}],40:[function(require,module,exports){
const { Game_Battler, Game_Action, Game_Enemy } = require("rmmz");
const utils = require("./utils");

class BattlerController {
    /**
     * 
     * @param {Game_Battler} battler 
     */
    constructor(battler) {
        this.battler = battler;
    }

    onTurnStart() {}

    onTurnEnd() {}

    /**
     * 
     * @param {Game_Action} action 
     */
    onActed(action) {}

    onCast(action, targets) {}

    onDead() {}
}

class EnemyController extends BattlerController {
    
    onTurnStart() {
        if (this.battler.isAlive())
            this.battler.makeActions();
    }
}

class PatternController extends EnemyController {

    /**
     * 
     * @param {Game_Enemy} battler 
     */
    constructor(battler) {
        super(battler);

        this.config = utils.noteData(battler.enemy());
        this._turnCount = this.config.begin_turn || 0;
    }

    onTurnStart() {
        let pattern = this.config.actions;
        let actions = pattern[this._turnCount % pattern.length];
        this._turnCount++;

        if (Array.isArray(actions)) {
            for (let actionId of actions) {
                let action = new Game_Action(this.battler, false);
                action.setSkill(actionId);
                this.battler.pushAction(action); 
            }
        } else {
            super.onTurnStart();
        }
    }
}

module.exports = {
    BattlerController,
    EnemyController,
    PatternController,
};
},{"./utils":58,"rmmz":32}],41:[function(require,module,exports){
const ColorRect = require("./color_rect");
const Input = require('./input');

const State = {
    Normal: 0,
    Hover: 1,
    Pressed: 2,
    Disabled: 3,
};

let textStyle = new PIXI.TextStyle({
    fontFamily: 'Arial',
    fill: ['#ffffff'],
    stroke: '#004620',
    fontSize: 14,
    fontWeight: 'lighter',
    lineJoin: 'round',
    strokeThickness: 1,
    stroke: '0x222222',
    wordWrap: true,
    wordWrapWidth: 180,
});

let hoverStyle = textStyle.clone();
hoverStyle.fill = '0x202040';

let disabledStyle = textStyle.clone();
disabledStyle.fill = '0x999999';

const _IconSize = 32;

class Button extends PIXI.Container {

    /**
     * 
     * @param {number}  width 
     * @param {number}  height 
     * @param {Object}  options 
     * @param {boolean} options.enable
     * @param {String}  options.text
     * @param {PIXI.DisplayObject} options.icon 
     */
    constructor(width, height, options = {}) {
        super();

        this._background = new ColorRect();
        this._background.corner = 4;
        this.addChild(this._background);
        this.interactive = true;

        let enable = options.enable;
        if (enable === undefined) enable = true;
        
        this._state = enable ? State.Normal : State.Disabled;
        this._mouseover = false;
        this.addListener('mouseover', () => {
            if (this._state === State.Normal) {
                this._state = State.Hover;
                this._update();
            }
            this._mouseover = true;
        });
        this.addListener('mouseout', () => {
            if (this._state === State.Hover) {
                this._state = State.Normal;
                this._update();
            }
            this._mouseover = false;
        });
        this.addListener('mousedown', () => {
            if (this._state === State.Disabled) return;
            if (this._state !== State.Pressed) {
                this._state = State.Pressed;
                this._update();
            }
        });
        let mouseup = () => {
            if (this._state === State.Pressed) {
                this._state = this._mouseover ? State.Hover : State.Normal;
                this._update();
            }
        };
        this.addListener('mouseup', mouseup);
        this.addListener('mouseupoutside', mouseup);

        this.addListener('click', ()=> {
            if (this._state !== State.Disabled) {
                this.emit('check');
            }
        });

        this._onChecked = () => {
            if (this.active && this._state !== State.Disabled) {
                this.emit('check');
            }
        };
        Input.event('ok').on('down', this._onChecked);

        this._label = new PIXI.Text('', textStyle);
        this.addChild(this._label);

        this.width = width;
        this.height = height;
        this.text = options.text;
        if (options.icon) {
            this._icon = options.icon;
            this.addChild(this._icon);
        }
        this._update();
    }

    set width(w) {
        if (this._width !== w) {
            this._width = w;
            this._background.width = w;
            this._updateTextPosition();
        }
    }

    get width() {
        return this._width;
    }

    set height(h) {
        if (this._height !== h) {
            super._height = h;
            this._background.height = h;
            this._updateTextPosition();
        }
    }

    get height() {
        return this._height;
    }

    set text(v) {
        this._label.text = v;
        this._label.calculateBounds();
        this._updateTextPosition();
    }

    get text() {
        return this._label.text;
    }

    set active(v) {
        if (this._active != v) {
            this._active = v;
            this._update();
        }
    }

    get active() {
        return this._active;
    }

    _updateTextPosition() {
        if (this._icon) {
            this._icon.x = (_IconSize - this._icon.width) * 0.6;
            this._icon.y = (this.height - this._icon.height) / 2;
            this._label.x = _IconSize + ((this.width - _IconSize) - this._label.width) / 2;
            this._label.y = (this.height - this._label.height) / 2;
        } else {
            this._label.x = (this.width - this._label.width) / 2;
            this._label.y = (this.height - this._label.height) / 2;
        }
    }

    _update() {
        if (this._active && this._state !== State.Pressed && this._state !== State.Disabled) {
            this._label.style = hoverStyle;
            this._background.color = 0xaaaaaa;
            return;
        }
        switch (this._state) {
            case State.Normal: {
                this._label.style = textStyle;
                this._background.color = 0x202040;
                break;
            }
            case State.Hover: {
                this._label.style = hoverStyle;
                this._background.color = 0x666666;
                break;
            }
            case State.Pressed: {
                this._label.style = hoverStyle;
                this._background.color = 0xcccccc;
                break;
            }
            case State.Disabled: {
                this._label.style = disabledStyle;
                this._background.color = 0x202040;
                break;
            }
        }
    }

    destroy(options) {
        super.destroy(options);
        Input.event('ok').off('down', this._onChecked);
    }
}

module.exports = Button;
},{"./color_rect":42,"./input":46}],42:[function(require,module,exports){

class ColorRect extends PIXI.Graphics {

    constructor() {
        super();
        this._corner = 0;
    }

    set width(w) {
        if (this._width !== w) {
            this._width = w;
            this._update();
        }
    }

    get width() {
        return this._width || 0;
    }

    set height(h) {
        if (this._height !== h) {
            this._height = h;
            this._update();
        }
    }

    get height() {
        return this._height || 0;
    }

    set color(v) {
        if (this._color !== v) {
            this._color = v;
            this._update();
        }
    }

    get color() {
        return this._color;
    }

    set corner(v) {
        if (this._corner !== v) {
            this._corner = v;
            this._update();
        }
    }

    get corner() {
        return this._corner;
    }

    _update() {
        this.clear();
        if (this._color && this._width && this._height) {
            this.beginFill(this._color);
            this.drawRoundedRect(0, 0, this._width, this._height, this._corner);
            this.endFill();
        }
    }
}

module.exports = ColorRect;
},{}],43:[function(require,module,exports){
const { Sprite, RPG, Sprite_AnimationMV, Sprite_Animation } = require("rmmz");


/**
 * 
 * @param {RPG.DataAnimation} animation
 * @param {Array<PIXI.DisplayObject>} targets
 */
function createAnimation(animation, targets) {
    function isMVAnimation(animation) {
        return !!animation.frames;
    }
    let sprite = new (isMVAnimation(animation) ? Sprite_AnimationMV : Sprite_Animation)();
    sprite.setup(
        targets, animation, true, 0, null
    );
    let emited = false;
    let oldUpdate = sprite.update;
    sprite.update = function() {
        oldUpdate.call(this);
        if (!this.isPlaying()) {
            if (!emited) {
                emited = true;
                this.emit('complete');
            }
        }
    };
    return sprite;
}

module.exports = createAnimation;
},{"rmmz":32}],44:[function(require,module,exports){

const { Easing } = require('@tweenjs/tween.js');
const ColorRect = require('./color_rect');
const TweenManager = require('./tween_manager');

let textStyle = new PIXI.TextStyle({
    fontFamily: 'Arial',
    fill: ['#ffffff'],
    stroke: '#004620',
    fontSize: 14,
    fontWeight: 'lighter',
    lineJoin: 'round',
    strokeThickness: 1,
    stroke: '0x222222',
    wordWrap: true,
    wordWrapWidth: 180,
});

const _Padding = {
    x: 4,
    y: 4
};
class Hint extends PIXI.Sprite {
    constructor() {
        super();

        this._background = new ColorRect();
        this._background.color = 0x202040;
        this._background.alpha = 0.6;
        this._label = new PIXI.Text('', textStyle);
        this.alpha = 0;

        this.tweens = new TweenManager();

        this.addChild(this._background);
        this.addChild(this._label);
    }
    
    set text(v) {
        if (this._text !== v) {
            this._text = v;
            this._update();
        }
    }

    get text() {
        return this._text;
    }

    _update() {
        if (this._text) {
            let textMetrics = PIXI.TextMetrics.measureText(this._text, textStyle);
            this._background.width = textMetrics.width + _Padding.x * 2;
            this._background.height = textMetrics.height + _Padding.y * 2;
            this._label.text = this._text;
            this._label.width = textMetrics.width;
            this._label.height = textMetrics.height;
            this._label.x = _Padding.x;
            this._label.y = _Padding.y;
            // this.width = textMetrics.width;
            // this.height = textMetrics.height;
        }
    }

    async appear(x, y) {
        let cx = x - (this.width + _Padding.x * 2) / 2;

        if (this.alpha <= 0.04) {
            this.x = cx;
            this.y = y + 40;
        }
        await this.tweens.tween(this).to({
            x: cx,
            y: y + 20,
            alpha: 1,
        }, 400).easing(Easing.Cubic.Out).run();
    }

    async disappear() {
        let cx = this.x;
        await this.tweens.tween(this).to({
            x: cx,
            y: this.y + 20,
            alpha: 0,
        }, 400).easing(Easing.Cubic.Out).run();
    }

    destroy(options) {
        super.destroy(options);
        this.tweens.destroy();
    }
}

module.exports = Hint;
},{"./color_rect":42,"./tween_manager":57,"@tweenjs/tween.js":2}],45:[function(require,module,exports){
const { Sprite, ImageManager, Bitmap } = require("rmmz");


function _loadBitmap(iconIndex, w, h) {
    if (!iconIndex) return null;
    const bitmap = ImageManager.loadSystem("IconSet");
    const pw = ImageManager.iconWidth;
    const ph = ImageManager.iconHeight;
    const sx = (iconIndex % 16) * pw;
    const sy = Math.floor(iconIndex / 16) * ph;
    let iconBitmap = new Bitmap(w, h);
    iconBitmap.blt(bitmap, sx, sy, pw, ph, 0, 0, w, h);
    return iconBitmap;
}

class Icon extends Sprite {
    constructor(w, h) {
        super(null);
        this.width = w;
        this.height = h;
    }

    set iconIndex(v) {
        if (this._iconIndex !== v) {
            this._iconIndex = v;
            this.bitmap = _loadBitmap(v, this.width, this.height);
        }
    }

    get iconIndex() {
        return this._iconIndex;
    }

}

module.exports = Icon;
},{"rmmz":32}],46:[function(require,module,exports){
const { Input } = require("rmmz");
const EventEmitter = require('events');

class KeyEvent extends EventEmitter {
    constructor(keyName) {
        super();
        this.keyName = keyName;
        this.isPressed = false;

        if (keyName === 'cancel') {
            window.addEventListener('mousedown', (e) => {
                let rightclick;
                if (e.which) rightclick = (e.which == 3);
                else if (e.button) rightclick = (e.button == 2);
                if (rightclick) {
                    this.emit('down');
                }
            });
            window.addEventListener('mouseup', (e) => {
                let rightclick;
                if (e.which) rightclick = (e.which == 3);
                else if (e.button) rightclick = (e.button == 2);
                if (rightclick) {
                    this.emit('up');
                }
            });
        }
    }

    update() {
        let pressed = Input.isPressed(this.keyName);
        if (pressed !== this.isPressed) {
            this.isPressed = pressed;
            if (pressed) {
                this.emit('down');
            } else {
                this.emit('up');
            }
        }
        if (Input.isRepeated(this.keyName)) {
            this.emit('repeat');
        }
    }
}

let _eventMap = {};

let _Input_update = Input.update;
Input.update = function () {
    _Input_update.call(this);

    for (let key in _eventMap) {
        let event = _eventMap[key];
        event.update();
    }
}

/**
 * 
 * @param {string} keyName 
 * @returns {KeyEvent}
 */
Input.event = function(keyName) {
    let keyEvent = _eventMap[keyName];
    if (!keyEvent) {
        keyEvent = new KeyEvent(keyName);
        _eventMap[keyName] = keyEvent;
    }
    return keyEvent;
};

module.exports = Input;
},{"events":3,"rmmz":32}],47:[function(require,module,exports){
const { Game_Battler, RPG } = require("rmmz");
const ColorRect = require("./color_rect");
const utils = require("./utils");
const RichText = require("rm-rich");

const _Size = {
    w: 240,
};
const _Padding = {
    x: 4,
    y: 4
};
let textStyle = new PIXI.TextStyle({
    fontFamily: 'Arial',
    fill: '#ffffff',
    stroke: '#004620',
    fontSize: 14,
    fontWeight: 'lighter',
    lineJoin: 'round',
    strokeThickness: 1,
    stroke: '0x222222',
    wordWrap: true,
    wordWrapWidth: 120,
});

let detailsStyle = textStyle.clone();
detailsStyle.wordWrapWidth = _Size.w - _Padding.x * 2;

class ItemDetails extends PIXI.Container {

    constructor() {
        super();

        this._background = new ColorRect();
        this._background.color = 0x202040;
        this._background.alpha = 0.6;
        this._background.width = _Size.w;
        this.addChild(this._background);

        this._title = new PIXI.Text('', textStyle);
        this._title.x = _Padding.x;
        this._title.y = _Padding.y;
        this.addChild(this._title);

        this._content = new PIXI.Text('', detailsStyle);
        this._content.x = _Padding.x;
        this._content.y = _Padding.y + 22;
        this.addChild(this._content);

        this._detailsLabel = new RichText('', textStyle, {
            mp: {
                fill: '#6666ff',
            },
            cd: {
                fill: '#66ff66',
            },
            tp: {
                fill: '#eeee66',
            }
        });
        this.addChild(this._detailsLabel);
    }

    /**
     * 
     * @param {RPG.Data} item 
     * @param {Game_Battler} battler 
     */
    setContent(item, battler) {
        const config = utils.noteData(item);
        this._title.text = item.name;

        this._content.text = item.description;
        let textMetrics = PIXI.TextMetrics.measureText(item.description, detailsStyle);
        this._background.height = 22 + textMetrics.height + _Padding.y * 2;

        let arr = [];
        if (config.cooldown) {
            let cd = battler.getCooldownCount(item.id);
            let cdStr;
            if (cd) {
                cdStr = `(${cd})`;
            } else {
                cdStr = '';
            }
            arr.push(`<cd>CD:${config.cooldown}${cdStr}</cd>`);
        }
        if (item.mpCost) {
            arr.push(`<mp>MP:${item.mpCost}</mp>`);
        } 
        if (item.tpCost) {
            arr.push(`<tp>TP:${item.tpCost}</tp>`);
        }
        this._detailsLabel.text = arr.join('  ');
        this._detailsLabel.x = _Size.w - this._detailsLabel.width - _Padding.x;
        this._detailsLabel.y = _Padding.y;

    }
}

module.exports = ItemDetails;
},{"./color_rect":42,"./utils":58,"rm-rich":30,"rmmz":32}],48:[function(require,module,exports){

const Scroller = require('./scoller');
const Input = require('./input');

class List extends Scroller {

    /**
     * 
     * @param {Object} options
     * @param {number} options.width
     * @param {number} options.height
     * @param {Array} options.items
     */
    constructor(options) {
        super(options);

        this._items = options.items;

        let offset = 0;

        for (let idx = 0; idx < this._items.length; ++idx) {
            let child = this._items[idx];
            child.x = 0;
            child.y = offset;
            child.width = options.width;
            offset += child.height + 1;
            this.content.addChild(child);

            child.addListener('mouseover', () => {
                this.highlight = idx;
            });
        }

        this._onUpPressed = ()=> {
            if (this.type === Scroller.TYPE_VERTICAL) {
                if (this.highlight === -1) {
                    this.highlight = this._items.length - 1;
                } else {
                    if (this.highlight > 0) {
                        this.highlight -= 1;
                    } else {
                        this.highlight = this._items.length - 1;
                    }
                }
                this.show(this.highlight);
            }
        };
        this._onDownPressed = ()=> {
            if (this.type === Scroller.TYPE_VERTICAL) {
                if (this.highlight === -1) {
                    this.highlight = 0;
                } else {
                    if (this.highlight < this._items.length - 1) {
                        this.highlight += 1;
                    } else {
                        this.highlight = 0;
                    }
                }
                this.show(this.highlight);
            }
        };

        this.active = true;
        this.highlight = 0;
    }

    set active(v) {
        if (this._active !== v) {
            this._active = v;

            if (v) {
                this._changeSelect(-1, this._highlight);
                Input.event("up").on('down', this._onUpPressed);
                Input.event("down").on("down", this._onDownPressed);
            } else {
                this._changeSelect(this._highlight, -1);
                Input.event("up").off('down', this._onUpPressed);
                Input.event("down").off("down", this._onDownPressed);
            }
        }
    }

    get active() {
        return this._active;
    }

    set highlight(v) {
        v = Math.round(v);
        if (this._highlight !== v && v >= 0 && v < this._items.length) {
            this._changeSelect(this._highlight, v);
            this._highlight = v;
        }
    }

    get highlight() {
        return this._highlight;
    }

    set type(v) {
        if (this._type !== v) {
            this._type = v;
        }
    }

    get type() {
        return this._type;
    }

    get items() {
        return this._items;
    }

    _changeSelect(old, sel) {
        if (old >= 0 && old < this._items.length) {
            this._items[old].active = false;
        }
        if (sel >= 0 && sel < this._items.length) {
            let item = this._items[sel];
            item.active = true;

            this.emit('highlight', sel);
        }
    }

    show(sel) {
        let item = this._items[sel];
        if (this.type === List.TYPE_VERTICAL) {
            let low = item.y;
            let high = item.y + item.height;
            let vp = this.viewport;
            if (vp.top > low) {
                this.scrollTo(0, low);
            } else if (vp.bottom < high) {
                this.scrollTo(0, Math.max(0, high - vp.height));
            }
        }
    }
    
    destroy(options) {
        super.destroy(options);

        Input.event("up").off('down', this._onUpPressed);
        Input.event("down").off("down", this._onDownPressed);
    }
}

module.exports = List;
},{"./input":46,"./scoller":54}],49:[function(require,module,exports){
const Scroller = require("./scoller");
const TweenManager = require("./tween_manager");
const RichText = require('rm-rich');
const { Game_Actor, Game_Battler, DataManager, RPG, TextManager, Game_Enemy, Game_Action } = require("rmmz");

class LogBox extends PIXI.Container {

    /**
     * 
     * @param {Object} options 
     * @param {number} options.width
     * @param {number} options.height
     */
    constructor(options) {
        super();

        this.inner = new LogBoxInner({
            width: options.width - 20,
            height: options.height - 20
        });
        this.inner.x = 10;
        this.inner.y = 10;
        this.addChild(this.inner);

        this.interactive = true;

        this.tweens = new TweenManager();

        this._mouseOver = false;
        this.addListener('mouseover', ()=> {
            this.appear();
            this._mouseOver = true;
        });
        this.addListener('mouseout', ()=>{
            this._mouseOver = false;
            this.countToDismiss();
        });
    }

    destroy(options) {
        super.destroy(options);
        this.tweens.destroy();
    }
 
    add(text) {
        if (!text) return;
        this.inner.add(text);

        this.appear();
        this.countToDismiss();
    }

    appear() {
        this.tweens.tween(this).to({
            alpha: 1,
        }, 300).run();
    }

    countToDismiss() {
        if (this._timer) {
            clearTimeout(this._timer);
            this._timer = null;
        }
        if (this._mouseOver) return;
        this._timer = setTimeout(()=>{
            this.dismiss();
        }, 3000);
    }

    dismiss() {
        if (this._timer) {
            clearTimeout(this._timer);
            this._timer = null;
        }
        if (this._mouseOver) return;
        this.tweens.tween(this).to({
            alpha: 0,
        }, 300).run();
    }

    /**
     * 
     * @param {Game_Actor} subject 
     * @param {Game_Action} action 
     */
    displayAction(subject, action) {
        const item = action.item();
        if (DataManager.isSkill(item)) {
            this.add(item.message1.format(this._battler(subject), this._item(item)));
            this.add(item.message2.format(this._battler(subject), this._item(item)));
        } else {
            this.add(TextManager.useItem.format(this._battler(subject), this._item(item)));
        }
    }

    /**
     * 
     * @param {Game_Battler} subject 
     * @param {Game_Battler} target 
     */
    displayResult(subject, target) {
        let result = target.result();
        if (result.used) {
            if (result.critical) {
                if (target.isActor()) {
                    this.add(TextManager.criticalToActor);
                } else {
                    this.add(TextManager.criticalToEnemy);
                }
            }
            if (result.missed) {
                if (result.physical) {
                    const isActor = target.isActor();
                    let fmt = isActor ? TextManager.actorNoHit : TextManager.enemyNoHit;
                    target.performMiss();
                    this.add(fmt.format(this._battler(target)));
                } else {
                    this.add(TextManager.actionFailure.format(this._battler(target)));
                }
            } else if (result.evaded) {
                let fmt;
                if (result.physical) {
                    fmt = TextManager.evasion;
                    target.performEvasion();
                } else {
                    fmt = TextManager.magicEvasion;
                    target.performMagicEvasion();
                }
                this.add(fmt.format(this._battler(target)));
            } else {
                if (result.hpAffected) {
                    let damage = result.hpDamage;
                    if (damage > 0 && !result.drain) {
                        target.performDamage();
                    } else if (damage < 0) {
                        target.performRecovery();
                    }
                    const isActor = target.isActor();
                    let fmt;
                    if (damage > 0 && result.drain) {
                        fmt = isActor ? TextManager.actorDrain : TextManager.enemyDrain;
                        this.add(fmt.format(this._battler(target), TextManager.hp, this._tag('dmg', damage)));
                    } else if (damage > 0) {
                        fmt = isActor ? TextManager.actorDamage : TextManager.enemyDamage;
                        this.add(fmt.format(this._battler(target), this._tag('dmg', damage)));
                    } else if (damage < 0) {
                        fmt = isActor ? TextManager.actorRecovery : TextManager.enemyRecovery;
                        this.add(fmt.format(this._battler(target), TextManager.hp, this._tag('heal', -damage)));
                    } else {
                        fmt = isActor ? TextManager.actorNoDamage : TextManager.enemyNoDamage;
                        this.add(fmt.format(this._battler(target)));
                    }
                }
                if (target.isAlive() && result.mpDamage !== 0) {
                    if (result.mpDamage < 0) {
                        target.performRecovery();
                    }
                    const damage = result.mpDamage;
                    const isActor = target.isActor();
                    let fmt;
                    if (damage > 0 && result.drain) {
                        fmt = isActor ? TextManager.actorDrain : TextManager.enemyDrain;
                        this.add(fmt.format(this._battler(target), TextManager.mp, this._tag('mp', damage)));
                    } else if (damage > 0) {
                        fmt = isActor ? TextManager.actorLoss : TextManager.enemyLoss;
                        this.add(fmt.format(this._battler(target), TextManager.mp, this._tag('mp', damage)));
                    } else if (damage < 0) {
                        fmt = isActor ? TextManager.actorRecovery : TextManager.enemyRecovery;
                        this.add(fmt.format(this._battler(target), TextManager.mp, this._tag('mp', -damage)));
                    } else {
                    }
                }
                if (target.isAlive() && result.tpDamage !== 0) {
                    if (result.tpDamage < 0) {
                        target.performRecovery();
                    }

                    const damage = result.tpDamage;
                    const isActor = target.isActor();
                    let fmt;
                    if (damage > 0) {
                        fmt = isActor ? TextManager.actorLoss : TextManager.enemyLoss;
                        this.add(fmt.format(this._battler(target), TextManager.tp, this._tag('tp', damage)));
                    } else if (damage < 0) {
                        fmt = isActor ? TextManager.actorGain : TextManager.enemyGain;
                        this.add(fmt.format(this._battler(target), TextManager.tp, this._tag('tp', -damage)));
                    } else {
                    }
                }
            }
        }
    }

    /**
     * 
     * @param {Game_Battler} target 
     * @param {boolean} current 
     */
    displayBattlerStatus(target, current) {
        const result = target.result();
        if (result.isStatusAffected()) {
            let states = result.addedStateObjects();
            for (const state of states) {
                const stateText = target.isActor() ? state.message1 : state.message2;
                if (state.id === target.deathStateId()) {
                    target.performCollapse();
                }
                if (stateText) {
                    this.add(stateText.format(this._battler(target)));
                }
            }
            states = result.removedStateObjects();
            for (const state of states) {
                if (state.message4) {
                    this.add(state.message4.format(this._battler(target)));
                }
            }
        }

        if (current) {
            const stateText = target.mostImportantStateText();
            if (stateText) {
                this.add(stateText.format(this._battler(target)));
            }
        }
        // if (target.shouldPopupDamage()) {
        //     target.startDamagePopup();
        // }
    }

    /**
     * 
     * @param {Game_Battler} battler 
     */
    _battler(battler) {
        return battler.isActor() ? this._ally(battler) : this._enemy(battler);
    }

    /**
     * 
     * @param {Game_Actor} actor 
     */
    _ally(actor) {
        return `<ally>${actor.name()}</ally>`;
    }

    /**
     * 
     * @param {Game_Enemy} actor 
     */
    _enemy(actor) {
        return `<enemy>${actor.name()}</enemy>`;
    }

    /**
     * 
     * @param {RPG.DataItemBase} item 
     */
    _item(item) {
        return `<item>${item.name}</item>`;
    }

    _tag(tag, hp) {
        return `<${tag}>${hp}</${tag}>`;
    }
}

class LogBoxInner extends Scroller {

    /**
     * 
     * @param {Object} options 
     * @param {number} options.width
     * @param {number} options.height
     */
    constructor(options) {
        super(options);

        this.textStyle = new PIXI.TextStyle({
            fontFamily: 'Arial',
            fill: ['#ffffff'],
            stroke: '#004620',
            fontSize: 16,
            fontWeight: 'lighter',
            lineJoin: 'round',
            strokeThickness: 2,
            stroke: '0x222222',
            wordWrap: true,
            wordWrapWidth: options.width,
        });
        this.tagStyles = {
            ally: {
                fill: "#ffc400",
                fontSize: 18,
            },
            enemy: {
                fill: "#b50e0e",
                fontSize: 18,
            },
            dmg: {
                fill: "#ff0000"
            },
            heal: {
                fill: "#00ff00"
            },
            mp: {
                fill: "#0000ff"
            },
            item: {
                fill: '#a8a8a8'
            },
            tp: {
                fill: '#00c900'
            }
        };

        this.offset = 0;
        this.content.y = options.height;
    }

    add(text) {
        const label = new RichText(text, this.textStyle, this.tagStyles);
        label.x = 0;
        label.y = this.offset;
        this.offset += label.height;
        this.content.addChild(label);

        this.scrollTo(0, this.offset - this.height);
    }
}

module.exports = LogBox;
},{"./scoller":54,"./tween_manager":57,"rm-rich":30,"rmmz":32}],50:[function(require,module,exports){
const { Easing } = require("@tweenjs/tween.js");
const Scroller = require("./scoller");
const TweenManager = require("./tween_manager");

class Pager extends Scroller {
    
    /**
     * @param {PIXI.Container} child 
     */
    constructor(child) {
        super();

        this.type = Scroller.TYPE_HORIZONTAL;

        this.stack = [child];
        this.content.addChild(child);
        child.x = 0;
        child.y = 0;
        this._active = false;

        this.interactive = false;

        this.tweens = new TweenManager();
    }

    destroy(options) {
        super.destroy(options);
        this.tweens.destroy();
    }

    get current() {
        return this.stack[this.stack.length - 1];
    }

    get width() {
        return super.width;
    }

    set width(v) {
        super.width = v;
        this.current.width = v;
    }

    get height() {
        return super.height;
    }

    set height(v) {
        super.height = v;
        this.current.height = v;
    }

    /**
     * 
     * @param {PIXI.DisplayObject} child 
     */
    async push(child) {
        let old = this.current;
        let len = this.stack.length;
        child.x = len * this.width;
        child.y = 0;
        child.width = this.width;
        child.height = this.height;
        this.stack.push(child);
        old.active = false;
        child.active = this.active;
        this.content.addChild(child);

        await this.scrollTo(len * this.width, 0);
    }

    async pop() {
        if (this.stack.length <= 1) return;
        let top = this.stack.pop();
        let cur = this.current;
        top.active = false;
        cur.active = this.active;
        await this.scrollTo((this.stack.length - 1) * this.width, 0);
        return top;
    }

    set active(v) {
        if (this._active !== v) {
            this._active = v;
            this.current.active = v;
        }
    }

    get active() {
        return this._active;
    }
}

module.exports = Pager;
},{"./scoller":54,"./tween_manager":57,"@tweenjs/tween.js":2}],51:[function(require,module,exports){
(()=>{

class MousewheelPlugin{
	constructor(app){
		this.app = app

		this.eventHandler = e=>this.onMouseWheel(e)
		this.app.view.addEventListener('mousewheel',this.eventHandler, { passive: false })
		this.app.view.addEventListener('DOMMouseScroll',this.eventHandler, { passive: false })
	}

	onMouseWheel(e){
		let target = this.findScrollTarget({x:e.offsetX,y:e.offsetY})

		if(target){
			e.preventDefault()
			target.emit('mousewheel', this.deriveNormalizedWheelDelta(e), e)
		}
	}

	findScrollTarget(pos){
		let hit = this.app.renderer.plugins.interaction.hitTest(pos)
		
		while (hit) {
			if(hit && hit.interactiveMousewheel)
				return hit
			hit = hit.parent;
		}
	}

	deriveNormalizedWheelDelta(e){
		if(e.detail){
			if(e.wheelDelta)
				return e.wheelDelta/e.detail/40 * (e.detail>0 ? 1 : -1) // Opera
			else
				return -e.detail/3 // Firefox
		}else
			return e.wheelDelta/120 // IE,Safari,Chrome
	}

	destroy(){
		this.app.view.removeEventListener('mousewheel',this.eventHandler)
		this.app.view.removeEventListener('DOMMouseScroll',this.eventHandler)
	}
}




Object.defineProperty(PIXI.DisplayObject.prototype, 'interactiveMousewheel', {
	get: function(){
		return this._interactiveMousewheel
	},
	set: function(enabled){
		this._interactiveMousewheel = enabled
		
		if(enabled && !this.interactive){
			this.interactive = true
		}
	}
})


PIXI.Application.registerPlugin({
	init: function(options){
		this._mousewheelPlugin = new MousewheelPlugin(this)
	},
	destroy: function(){
		this._mousewheelPlugin.destroy()
	}
})

})()
},{}],52:[function(require,module,exports){
const { Easing } = require("@tweenjs/tween.js");
const { Graphics } = require("rmmz");
const TweenManager = require("./tween_manager");

const missedStyle = new PIXI.TextStyle({
    dropShadow: true,
    dropShadowAlpha: 0.5,
    dropShadowAngle: -0.6,
    dropShadowBlur: 3,
    dropShadowColor: "#545454",
    dropShadowDistance: 3,
    fill: "white",
    fontSize: 16,
    fontWeight: "bold",
    lineJoin: "bevel",
    stroke: "#454545",
    strokeThickness: 4
});

const physicStyle = missedStyle.clone();
physicStyle.fill = '#ff2424';

const magicStyle = missedStyle.clone();
magicStyle.fill = '#3cf';

const failedStyle = missedStyle.clone();
failedStyle.fill = '#a3a3a3';

class ResultText extends PIXI.Text {

    constructor(result) {
        let text;
        let style;
        if (!result.success) {
            text = 'Failed';
            style = failedStyle;
        } else if (result.missed) {
            text = 'Miss';
            style = missedStyle;
        } else if (result.evaded) {
            text = 'Evade';
            style = missedStyle;
        } else if (result.hpAffected) {
            text = '-' + result.hpDamage;
            style = result.physical ? physicStyle : magicStyle;
        } else {
            text = '0';
            style = physicStyle;
        }

        if (result.critical) {
            style = style.clone();
            style.fontSize = 22;
            style.strokeThickness = 6;
            style.dropShadowColor = "#ffa200";
            style.stroke = "#fb0";
        }

        super(text, style);

        this.anchor.set(0.5, 0.5);

        this.tweens = new TweenManager();
    }

    destroy(options) {
        this._finish();
        this.tweens.destroy();
        super.destroy(options);
    }

    _finish() {
        if (this._update) {
            Graphics.app.ticker.remove(this._update);
            this._update = null;
        }
    }

    /**
     * 
     * @param {Object} speed 
     * @param {number} speed.x
     * @param {number} speed.y
     * @returns 
     */
    jump(speed) {
        if (this._running) return;
        this._running = true;
        return new Promise((resolve, reject)=>{
            let ox = this.x, oy = this.y;
            let bottom = this.y + 46;
            let that = this;
            const gravy = 0.3;
            let bounce = 2;
            let speedx = speed.x, speedy = speed.y;
            function _complete() {
                that._finish();
                resolve(that.tweens.tween(that).to({
                    alpha: 0,
                }, 300).run());
            }
            function _update() {
                that.x += speedx;
                that.y += speedy;
                speedy += gravy;
                if (that.y >= bottom && speedy > 0) {
                    if (bounce <= 0) {
                        _complete();
                    } else {
                        bounce -= 1;
                        speedy = speedy * -0.4;
                    }
                }
            }
            this._update = _update;
            Graphics.app.ticker.add(_update);
        });
    }
}

module.exports = ResultText;
},{"./tween_manager":57,"@tweenjs/tween.js":2,"rmmz":32}],53:[function(require,module,exports){
const { SceneManager } = require("rmmz");

if (!SceneManager.replaceSceneClass) {
    let _sceneMap = {};
    function findClass(sceneClass) {
        return _sceneMap[sceneClass] || sceneClass;
    }
    
    let _old_goto = SceneManager.goto;
    SceneManager.goto = function(sceneClass) {
        return _old_goto.call(this, findClass(sceneClass));
    };
    
    let _old_run = SceneManager.run;
    SceneManager.run = function(sceneClass) {
        return _old_run.call(this, findClass(sceneClass));
    };
    
    let _old_push = SceneManager.push;
    SceneManager.push = function(sceneClass) {
        return _old_push.call(this, findClass(sceneClass));
    }
    
    let _old_isNextScene = SceneManager.isNextScene;
    SceneManager.isNextScene = function (sceneClass) {
        return _old_isNextScene.call(this, findClass(sceneClass));
    }
    
    let _old_isPreviousScene = SceneManager.isPreviousScene;
    SceneManager.isPreviousScene = function (sceneClass) {
        return _old_isPreviousScene.call(this, findClass(sceneClass));
    }
    
    SceneManager.replaceSceneClass = function (oldClass, newClass) {
        _sceneMap[oldClass] = newClass;
    };
}

module.exports = SceneManager;
},{"rmmz":32}],54:[function(require,module,exports){
const { Easing } = require("@tweenjs/tween.js");
const TweenManager = require("./tween_manager");

class Scroller extends PIXI.Container {

    /**
     * 
     * @param {number} options.width
     * @param {number} options.height
     */
    constructor(options = {}) {
        super();

        this._width = options.width || 48;
        this._height = options.height || 48;
        
        this.type = Scroller.TYPE_VERTICAL;

        this.content = new PIXI.Container();
        this.addChild(this.content);

        this._spriteMask = PIXI.Sprite.from(PIXI.Texture.WHITE);
        this.mask = this._spriteMask;
        // this.mask = new PIXI.Graphics();
        this.tweens = new TweenManager();
        this.addChild(this._spriteMask);

        this.interactive = true;
        this.interactiveMousewheel = true;
        this.pressed = false;
        this.addListener('mousedown', (e)=> {
            this._onMouseDown(e);
        });
        this.addListener('mouseup', (e) => {
            this._onMouseUp(e);
        });
        this.addListener('mouseupoutside', (e) => {
            this._onMouseUp(e);
        });
        this.addListener('mousemove', (e) => {
            this._onMouseMove(e);
        });
        this.addListener('mousewheel', (e) => {
            this._onMouseWheel(e);
        });
        this._oldPosition = new PIXI.Point(
            this.content.x,
            this.content.y
        );
        this._delta = new PIXI.Point();
        this._updateMask();
    }

    set width(w) {
        if (this._width !== w) {
            this._width = w;
            this._updateMask();
        }
    }

    get width() {
        return this._width;
    }

    set height(h) {
        if (this._height !== h) {
            this._height = h;
            this._updateMask();
        }
    }

    get height() {
        return this._height;
    }

    set x(x) {
        if (x !== super.x) {
            super.x = x;
            this._updateMask();
        }
    }

    get x() {
        return super.x;
    }

    set y(y) {
        if (y !== super.y) {
            super.y = y;
            this._updateMask();
        }
    }

    get y() {
        return super.y;
    }
    
    /**
     * @returns {PIXI.Rectangle}
     */
     get viewport() {
        if (!this._viewport) {
            this._viewport = new PIXI.Rectangle();
        }
        this._viewport.x = -this.content.x;
        this._viewport.y = -this.content.y;
        this._viewport.width = this.width;
        this._viewport.height = this.height;
        return this._viewport;
    }

    _updateMask() {
        this._spriteMask.width = this.width;
        this._spriteMask.height = this.height;
    }

    _onMouseDown(e) {
        this._oldPosition.x = e.data.global.x;
        this._oldPosition.y = e.data.global.y;
        this._delta.x = 0;
        this._delta.y = 0;
        this.pressed = true;
    }

    _onMouseUp(e) {
        this.pressed = false;
        if (this.type == Scroller.TYPE_VERTICAL) {
            if (this.content.height > this.height) {
                if (this.content.y > 0) {
                    this.tweens.tween(this.content).to({
                        y: 0
                    }, 400).easing(Easing.Bounce.Out).run();
                } else if (this.content.y < -(this.content.height - this.height)) {
                    this.tweens.tween(this.content).to({
                        y: Math.min(0, -(this.content.height - this.height)),
                    }, 400).easing(Easing.Bounce.Out).run();
                } else {
                    let target = Math.max(Math.min(0, this.content.y + this._delta.y * 60), -(this.content.height - this.height));
                    this.tweens.tween(this.content).to({
                        y: target
                    }, 400).easing(Easing.Cubic.Out).run();
                }
            }
        }
    }

    _onMouseMove(e) {
        if (this.pressed) {
            let offset = e.data.global.y - this._oldPosition.y;

            if (this.type == Scroller.TYPE_VERTICAL) {
                if (this.content.height > this.height) {
                    if (this.content.y > 0) {
                        offset /= 3;
                    } else if (this.content.y < -(this.content.height - this.height)) {
                        offset /= 3;
                    }
                    this.content.y += offset;
                }
            }

            this._delta.x = (e.data.global.x - this._oldPosition.x);
            this._delta.y = (e.data.global.y - this._oldPosition.y);
            this._oldPosition.x = e.data.global.x;
            this._oldPosition.y = e.data.global.y;
        }
    }

    _onMouseWheel(off) {
        if (this.type == Scroller.TYPE_VERTICAL) {
            if (this.content.height > this.height) {
                let target = this.content.y + off;
                if (target > 0) {
                    target = 0;
                } else if (target < -(this.content.height - this.height)) {
                    target = Math.min(0, -(this.content.height - this.height));
                }
                this.content.y = target;
            }
        }
    }

    /**
     * 
     * @param {number} x 
     * @param {number} y 
     */
     scrollTo(x ,y) {
        return this.tweens.tween(this.content).to({
            x: -x, y: -y
        }, 300).easing(Easing.Cubic.Out).run();
    }

    destroy(options) {
        super.destroy(options);
        this.tweens.destroy();
    }
}

Scroller.TYPE_VERTICAL = 0;
Scroller.TYPE_HORIZONTAL = 1;

module.exports = Scroller;
},{"./tween_manager":57,"@tweenjs/tween.js":2}],55:[function(require,module,exports){
const { Easing } = require("@tweenjs/tween.js");
const { Spriteset_Battle, Game_Battler, Sprite, Graphics, ImageManager, Stage, Game_Action, Game_Actor, SoundManager, Game_Enemy } = require("rmmz");
const ColorRect = require("./color_rect");
const Hint = require("./hint");
const Icon = require("./icon");
const TweenManager = require("./tween_manager");
const Input = require('./input');
const utils = require('./utils');
const ResultText = require("./result_text");
const ActorStateWindow = require("./actor_state_window");

let _old_onBitmapChange = Sprite.prototype._onBitmapChange;
Sprite.prototype._onBitmapChange = function() {
    _old_onBitmapChange.call(this);
    
    if (this._onbitmapCbs) {
        for (let cb of this._onbitmapCbs) {
            cb();
        }
    }
};

Sprite.prototype.onbitmap = function (fn) {
    if (!this._onbitmapCbs) {
        this._onbitmapCbs = [];
    }
    this._onbitmapCbs.push(fn);
};

const _BarSize = {
    w:60,
    h:4,
};
const _IconSize = {
    w: 16,
    h: 16,
}

const _ActiveEvent = 'active';

const textStyle = new PIXI.TextStyle({
    fontFamily: 'Arial',
    fill: ['#ff0000'],
    stroke: '#004620',
    fontSize: 10,
    fontWeight: 'lighter',
    lineJoin: 'round',
    strokeThickness: 1,
    stroke: '0x222222',
    wordWrap: true,
    wordWrapWidth: 180,
});

class ActionIcon extends Icon {

    constructor() {
        super(...arguments);
        this.tweens = new TweenManager();
        this._onActionActive = async () => {
            if (this.parent) {
                let icon = new Icon(this.width, this.height);
                icon.iconIndex = this.iconIndex;
                icon.x = this.x + this.width / 2;
                icon.y = this.y + this.height / 2;
                icon.anchor.set(0.5, 0.5);
                this.parent.addChild(icon);
                
                await this.tweens.tween(icon).to({
                    scale: {
                        x: 4,
                        y: 4,
                    },
                    alpha: 0
                }, 400).easing(Easing.Cubic.Out).run();
                icon.destroy({
                    children: true,
                    texture: true,
                    baseTexture: true,
                });
            }
        };

        this._label = new PIXI.Text('', textStyle);
        this._label.visible = false;
        this._label.anchor.set(0.5);
        this._label.position.set(this.width/2, this.height/2);
        this.addChild(this._label);
    }

    destroy(options) {
        super.destroy(options);
        if (this._action) {
            utils.ee(this._action).removeListener(_ActiveEvent, this._onActionActive);
        }
        this.tweens.destroy();
    }

    set action(v) {
        if (this._action !== v) {
            if (this._action) {
                utils.ee(this._action).removeListener(_ActiveEvent, this._onActionActive);
            }
            this._action = v;
            if (this._action) {
                utils.ee(this._action).addListener(_ActiveEvent, this._onActionActive);
            }
            this.iconIndex = this._action.item().iconIndex;
        }
    }

    get action() {
        return this._action;
    }

    update() {
        super.update();
        this._label.visible = this._action.isInterrupted();
    }
}

class EnemyState extends Sprite {
    
    /**
     * 
     * @param {Object} options
     * @param {Game_Battler} options.battler 
     * @param {Hint} options.hint 
     * @param {Sprite} options.sprite
     */
    constructor(options = {}) {
        super();

        let {battler, hint, sprite} = options;

        this.battler = battler;

        this._bar = new ColorRect();
        this._bar.color = 0x202040;
        this._bar.height = _BarSize.h + 2;
        this._bar.width = _BarSize.w + 2;
        this._bar.corner = 4;
        this._bar.y = _IconSize.h + 2;
        this.addChild(this._bar);

        this._hpBar = new ColorRect();
        this._hpBar.color = 0xff0000;
        this._hpBar.height = _BarSize.h;
        this._hpBar.width = _BarSize.w * battler.hp / battler.mhp;
        this._hpBar.x = 1;
        this._hpBar.y = _IconSize.h + 3;
        this._hpBar.corner = 4;
        this.addChild(this._hpBar);

        this._ohp = battler.hp;
        this.tweens = new TweenManager();

        this._actions = [];
        this._states = [];

        this._hint = hint;

        this.sprite = sprite;
        let rect = new ColorRect();
        sprite.onbitmap( () => {
            let bitmap = sprite.bitmap;
            bitmap.addLoadListener(() => {
                rect.width = bitmap.width;
                rect.height = bitmap.height;
                rect.color = 0x111111;
                rect.x = -bitmap.width / 2;
                rect.y = -bitmap.height;
                rect.alpha = 0;
                sprite.addChild(rect);

                this.x = -_BarSize.w / 2;
                this.y = -bitmap.height - _IconSize.h;
                sprite.addChild(this);
            });
        });
        this.rect = rect;
    }

    destroy(options) {
        super.destroy(options);
        this.tweens.destroy();
    }
    
    update() {
        super.update();

        if (this._ohp !== this.battler.hp) {
            this._hpChanged(this._ohp, this.battler.hp);
            this._ohp = this.battler.hp;
        }

        this._updateActions();
        this._updateStates();
    }

    _updateActions() {
        let actionsLength = this.battler.numActions();
        if (actionsLength < this._actions.length) {
            let actions = this._actions.splice(actionsLength, this._actions.length - actionsLength);
            for (let icon of actions) {
                icon.destroy({
                    children: true,
                    texture: true,
                    baseTexture: true,
                });
            }
        }
        for (let i = 0; i < actionsLength; ++i) {
            let actionData = this.battler.action(i);
            if (i < this._actions.length) {
                let icon = this._actions[i];
                icon.action = actionData;
            } else {
                let icon = new ActionIcon(_IconSize.w, _IconSize.h);
                this._actions.push(icon);
                icon.action = actionData;
                icon.x = i * (_IconSize.w + 2);
                icon.y = 0;
                icon.interactive = true;
                icon.addListener('mouseover', () => {
                    this._hint.text = icon.action.item().description || '_';
                    let point = icon.getGlobalPosition(new PIXI.Point(_IconSize.w/2, _IconSize.h/2));
                    this._hint.appear(point.x, point.y);
                });
                icon.addListener('mouseout', () => {
                    this._hint.disappear();
                });
                this.addChild(icon);
                
            }
        }
    }

    _updateStates() {
        let stateIcons = this.battler.stateIcons();
        if (stateIcons.length < this._states.length) {
            let states = this.this._states.splice(stateIcons.length, this._states.length - stateIcons.length);
            for (let icon of states) {
                this.removeChild(icon);
            }
        }

        for (let i = 0; i < stateIcons.length; ++i) {
            let iconIndex = stateIcons[i];
            if (i < this._states.length) {
                let action = this._states[i];
                action.iconIndex = iconIndex;
            } else {
                let action = new Icon(_IconSize.w, _IconSize.h);
                this._states.push(action);
                action.iconIndex = iconIndex;
                action.x = i * (_IconSize.w + 2);
                action.y = _IconSize.h + _BarSize.h + 4;
                this.addChild(action);
            }
        }
    }
    
    _hpChanged(ohp, nhp) {
        let tween = this.tweens.tween(this._hpBar)
            .to({width: _BarSize.w * nhp / this.battler.mhp}, 460);
        if (Math.abs(nhp / this.battler.mhp - ohp / this.battler.mhp) > 0.2) {
            tween.easing(Easing.Bounce.Out);
        } else {
            tween.easing(Easing.Cubic.Out);
        }
        tween.run();
    }

    set active(v) {
        if (this._active !== v) {
            this._active = v;
            this.rect.interactive = v;
            this._updateSprite();
        }
    }

    get active() {
        return this._active;
    }

    set highlight(v) {
        if (this._highlight !== v) {
            this._highlight = v;
            this._updateSprite();
        }
    } 

    get highlight() {
        return this._highlight && this.battler.isAlive();
    }

    get targetPosition() {
        return {
            x: this.sprite.x,
            y: this.sprite.y - this.rect.height + 32,
        };
    }

    _updateSprite() {
        if (this.highlight && this.active) {
            this.sprite.setBlendColor([255, 255, 255, 64]);
        } else {
            this.sprite.setBlendColor([0, 0, 0, 0]);
        }
    }
}

class Spriteset extends Spriteset_Battle {
    createEnemies() {
        super.createEnemies();

        this._hint = new Hint();

        this._active = false;
        this._states = [];
        for (let sprite of this._enemySprites) {
            let state = new EnemyState({
                battler: sprite._battler, 
                hint: this._hint,
                sprite: sprite,
            });
            state.rect.addListener('mouseover', () => {
                if (state.battler.isDead()) return;
                this.sprites.forEach((sprite) => sprite.highlight = false);
                state.highlight = true;
            });
            state.rect.addListener('mouseout', () => {
                if (state.battler.isDead()) return;
                state.highlight = false;
            });
            state.rect.addListener('click', (e) => {
                if (state.battler.isDead()) return;
                this.point = {
                    x: e.data.global.x,
                    y: e.data.global.y,
                };
                this.emit('select', state.battler);
            });
            this._states.push(state);

            sprite.startEffect("appear");
        }

        this.addChild(this._hint);
        
        let findHighlight = (status) => {
            for (let i = 0, t = status.length; i < t; ++i) {
                let state = status[i];
                if (state.highlight) {
                    return i;
                }
            }
            return -1;
        } 
        this._onPrevClicked = () => {
            if (this.active) {
                let states = this.selectableTargets;
                if (states.length === 0) return;
                let idx = findHighlight(states);
                let state;
                let old;
                if (idx == -1) {
                    state = states[states.length - 1];
                } else {
                    let i = idx - 1;
                    if (i < 0) {
                        i = states.length - 1;
                    }
                    old = states[idx];
                    state = states[i];
                }
                if (old) old.highlight = false;
                state.highlight = true;
            }
        };
        this._onNextClicked = () => {
            if (this.active) {
                let states = this.selectableTargets;
                if (states.length === 0) return;
                let idx = findHighlight(states);
                let state;
                let old;
                if (idx == -1) {
                    state = states[0];
                } else {
                    let i = idx + 1;
                    if (i >= states.length) {
                        i = 0;
                    }
                    old = states[idx];
                    state = states[i];
                }
                if (old) old.highlight = false;
                state.highlight = true;
            }
        };
        Input.event('left').on('down', this._onPrevClicked);
        Input.event('up').on('down', this._onPrevClicked);
        Input.event('right').on('down', this._onNextClicked);
        Input.event('down').on('down', this._onNextClicked);

        this._onChecked = () => {
            if (this.active) {
                let states = this.selectableTargets;
                if (states.length === 0) return;
                let idx = findHighlight(states);
                if (idx >= 0) {
                    let state = states[idx];
                    this.point = state.targetPosition;
                    this.emit('select', state.battler);
                } else {
                    let state = states[0];
                    state.highlight = true;
                }
            }
        };
        Input.event('ok').on('down', this._onChecked);

        let height = 180;
        const _SpriteWidth = 180;
        const statusWindow = new ActorStateWindow();
        statusWindow.x = _SpriteWidth + 20;
        statusWindow.y = Graphics.boxHeight - height;
        this._battleField.addChild(statusWindow);
        this._statusWindow = statusWindow;
        
        for (let actor of statusWindow.actors) {
            actor.addListener('mouseover', () => {
                this.sprites.forEach((sprite) => sprite.highlight = false);
                actor.highlight = true;
            });
            actor.addListener('mouseout', () => {
                actor.highlight = false;
            });
            actor.addListener('click', (e) => {
                this.point = {
                    x: e.data.global.x,
                    y: e.data.global.y,
                };
                this.emit('select', actor.actor);
            });
        }
    }

    async startTargetSelection() {
        return new Promise((resolve, reject)=> {
            this.active = true;
            this.once('select', (battler) => {
                this.active = false;
                resolve(battler);
            });
        });
    }

    destroy(options) {
        super.destroy(options);
        Input.event('left').off('down', this._onPrevClicked);
        Input.event('up').off('down', this._onPrevClicked);
        Input.event('right').off('down', this._onNextClicked);
        Input.event('down').off('down', this._onNextClicked);
        Input.event('ok').off('down', this._onChecked);
    }

    get sprites() {
        return [...this._states, ...this._statusWindow.actors];
    }

    get selectableTargets() {
        let enemies = this._states.filter((state) => state.battler.isAlive());
        return [...enemies, ...this._statusWindow.actors];
    }

    set active(v) {
        if (this._active !== v) {
            for (let sprite of this.sprites) {
                sprite.active = v;
            }
            this._active = v;
        }
    }

    get active() {
        return this._active;
    }

    /**
     * 
     * @param {Game_Actor} actor
     * @param {Array<Game_Battler>} targets 
     * @param {Game_Action} action 
     */
    async startActionAnimation(actor, targets, action) {
        let animationId = action.item().animationId;
        if (animationId < 0) {
            animationId = actor.attackAnimationId1();
        }
        if (animationId === 0) return;
        this.createAnimation({
            animationId: animationId,
            targets: targets,
            mirror: false,
        });
        let sprite = this._animationSprites[this._animationSprites.length - 1];
        return utils.until(sprite, 'animtion-over');
    }

    /**
     * 
     * @param {Game_Battler} target 
     * @returns 
     */
    async displayResultText(target) {
        let result = target.result();
        if (result.hpAffected || result.mpDamage || result.tpDamage) {
            let sprite = this.findTargetSprite(target);
            if (!sprite) return;
            let resultText = new ResultText(result);
            let pox = sprite.getGlobalPosition();
            resultText.x = pox.x;
            resultText.y = pox.y - sprite.height / 2;
            this.addChild(resultText);
            let neg = Math.random() - 0.5;
            neg = neg / Math.abs(neg);
            resultText.jump({
                x: (0.5 + Math.random() * 1.5) * neg,
                y: -6 + Math.random() * 2
            }).then(()=>{
                this.removeChild(resultText);
            });
            await utils.wait(240);
            if (target.isDead()) {
                switch (target.collapseType()) {
                    case 0:
                        sprite.startEffect("collapse");
                        SoundManager.playEnemyCollapse();
                        break;
                    case 1:
                        sprite.startEffect("bossCollapse");
                        SoundManager.playBossCollapse1();
                        break;
                    case 2:
                        sprite.startEffect("instantCollapse");
                        break;
                }
            }
        }
    }

    removeAnimation(sprite) {
        super.removeAnimation(sprite);
        sprite.emit('animtion-over');
    }

    /**
     * 
     * @param {Game_Battler} target 
     */
    findTargetSprite(target) {
        if (target.isEnemy()) {
            return super.findTargetSprite(target);
        } else {
            return this._statusWindow.findTargetSprite(target);
        }
    }
}

module.exports = Spriteset;
},{"./actor_state_window":36,"./color_rect":42,"./hint":44,"./icon":45,"./input":46,"./result_text":52,"./tween_manager":57,"./utils":58,"@tweenjs/tween.js":2,"rmmz":32}],56:[function(require,module,exports){
const Icon = require("./icon");
const {RPG, Game_Actor, Game_Battler, Graphics} = require('rmmz');
const Hint = require("./hint");
const utils = require("./utils");

const IconType = {
    Icon: 0,
    State: 1,
};

const textStyle = new PIXI.TextStyle({
    fontFamily: 'Arial',
    fill: ['#ffffff'],
    stroke: '#004620',
    fontSize: 10,
    fontWeight: 'lighter',
    lineJoin: 'round',
    strokeThickness: 2,
    stroke: '0x222222',
    wordWrap: true,
    wordWrapWidth: 180,
});

class StateIcon extends Icon {
    constructor() {
        super(24, 24);

        this._label = new PIXI.Text('', textStyle);
        this.addChild(this._label);
        this._label.visible = false;
        this._label.anchor.set(1, 1);
        this._label.x = 23;
        this._label.y = 23;

        this._update = ()=> this._onUpdate();
        Graphics.app.ticker.add(this._update);
    }

    destroy(options) {
        super.destroy(options);
        Graphics.app.ticker.remove(this._update);
    }

    /**
     * 
     * @param {Object} options
     * @param {IconType} options.type
     * @param {number} options.iconIndex
     * @param {RPG.DataState} options.state
     * @param {Game_Battler} options.battler
     */
    setData(options) {
        this.options = options;
        switch (options.type) {
            case IconType.Icon: {
                this.iconIndex = options.iconIndex;
                break;
            }
            case IconType.State: {
                this.iconIndex = options.state.iconIndex;
                break;
            }
        }
    }

    _onUpdate() {
        const { state, battler } = this.options;
        const { maxstacks } = utils.noteData(state);
        if (maxstacks > 1) {
            this._label.text = Math.round(battler.stacks(state.id)).toString();
            this._label.visible = true;
        } else {
            this._label.visible = false;
        }
    }
}

StateIcon.Type = IconType;

module.exports = StateIcon;
},{"./hint":44,"./icon":45,"./utils":58,"rmmz":32}],57:[function(require,module,exports){
const TWEEN = require("@tweenjs/tween.js");
const { Graphics } = require("rmmz");

let _tweenInit = false;
function _setup() {
    if (!_tweenInit) {
        _tweenInit = true;
        Graphics.app.ticker.add(function (time) {
            TWEEN.update(Graphics.app.ticker.lastTime);
        });
    }
}

class Tween extends TWEEN.Tween {

    run() {
        return new Promise((resolve, reject) => {
            let over = false;
            this.onComplete(function() {
                if (!over) {
                    over = true;
                    resolve();
                }
            });
            this.onStop(function() {
                if (!over) {
                    over = true;
                    resolve();
                }
            });
            this.start();
        });
    }
}

class TweenManager {
    constructor() {
        _setup();
        this._tweens = [];
    }

    _find(key) {
        for (let entry of this._tweens) {
            if (entry.key === key) {
                return entry;
            }
        } 
        return {
            key: key,
        };
    }

    _set(entry) {
        let index = this._tweens.indexOf(entry);
        if (index < 0) {
            this._tweens.push(entry);
        }
    }

    _remove(entry) {
        let index = this._tweens.indexOf(entry);
        if (index >= 0) {
            this._tweens.splice(index, 1);
        }
    }

    /**
     * 
     * @param {*} target 
     * @param {*} pros 
     * @returns {Tween}
     */
    tween(target) {
        let entry = this._find(target);
        let tween = entry.value;
        if (tween) {
            tween.stop();
        }
        tween = new Tween(target);
        entry.value = tween;
        this._set(entry);
        return tween;
    }

    stop(target) {
        let entry = this._find(target);
        let tween = entry.value;
        if (tween) {
            tween.stop();
            this._remove(entry);
        }
    }

    destroy() {
        for (let entry of this._tweens) {
            let tween = entry.value;
            tween.stop();
        }
        this._tweens = [];
    }
}

module.exports = TweenManager;
},{"@tweenjs/tween.js":2,"rmmz":32}],58:[function(require,module,exports){
const EventEmitter = require("events");
const { Bitmap } = require("rmmz");
const YAML = require('js-yaml');

module.exports = {
    wait(time) {
        return new Promise((resolve, reject) => setTimeout(resolve, time));
    },
    /**
     * 
     * @param {EventEmitter} target 
     * @param {string} name 
     * @returns {Promise}
     */
    until(target, name) {
        return new Promise(function (resolve, reject) {
            target.once(name, resolve)
        });
    },
    /**
     * 
     * @param {Object} object 
     * @returns {EventEmitter}
     */
    ee(object) {
        if (!object._ee) {
            object._ee = new EventEmitter();
        }
        return object._ee;
    },
    /**
     * 
     * @param {Bitmap} bitmap 
     */
    bitmapReady(bitmap) {
        return new Promise(function (resolve, reject) {
            if (bitmap.isReady()) {
                resolve(bitmap);
            } else {
                bitmap.addLoadListener(function _ready(self) {
                    resolve(bitmap);
                });
            }
        });
    },
    noteData(obj) {
        if (!obj._noteData) {
            obj._noteData = YAML.load(obj.note) || {};
        }
        return obj._noteData;
    },
    /**
     * 
     * @param {String} formula 
     * @param {Array<String>} keys 
     * @returns 
     */
    formula(formula, keys) {
        let arr = [];
        for (let key of keys) {
            arr.push(`const ${key} = args[${JSON.stringify(key)}];`);
        }
        arr.push(`return (${formula})`);
        return new Function('args', arr.join('\n'));
    }
};
},{"events":3,"js-yaml":4,"rmmz":32}]},{},[1]);
